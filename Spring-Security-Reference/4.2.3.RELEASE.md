> 아직 작성중입니다.
> 내용의 이해를 위해 있는 그대로 내용을 번역하는 것이 아니라 일부 의역<sup id="footkey0">[#0](#footnote0)</sup>하고 있습니다.
>
> __<sub id="footnote0">#0</sub>__ <sub>의역이란, 원문의 단어나 구절에 지나치게 얽매이지 않고 전체의 뜻을 살리어 번역하는 것을 의미한다. (참고: http://krdic.naver.com/detail.nhn?docid=30274000) -옮긴이 ([읽던 곳으로 돌아가기](#footkey0))</sub>

# Spring Security Reference

### 출처
https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/

### 작성자
Ben Alex, Luke Taylor, Rob Winch, Gunnar Hillert

### 번역
ssosso

(잘못된 번역은 github.com/ssosso/Docs-Traslation/Spring_Security_Reference에 pull request 또는 ssossohow@gmail.com)

### 버전
__4.2.3.RELEASE__


Copyright ⓒ 2004-2015
이 문서의 복사본에 대한 어떠한 요금도 청구하지 않고 저작권 고지사항이 포함되어 있다면, 인쇄물이든 전자문서이든 상관없이 복사하여 사용하고 다른 사람에게 배포할 수 있습니다.

## 목차

### [[1] 서문](#1-서문-1)

#### [1. 시작하기](#1-시작하기-1)

#### [2. 소개](#2-소개-1)
- [2.1. Spring Security란?](#21-spring-security란)
- [2.2. 연혁](#22-연혁)
- [2.3. 배포버전(Realease Numbering)](#23-배포버전realease-numbering)
- [2.4. Spring Security 시작하기](##24-spring-security-시작하기)
   - [2.4.1. Maven으로 시작하기](#241-maven으로-시작하기)
      - [Maven Repositories](#maven-repositories)
      - [Spring Framework Bom](#spring-framework-bom)
   - [2.4.2. Gradle로 시작하기](#242-gradle로-시작하기)
      - [Gradle Repositories](#gradle-repositories)
      - [Spring 4.0.x와 Gradle 사용하기](#spring-40x와-gradle-사용하기)
   - [2.4.3. 프로젝트 모듈](#243-프로젝트-모듈)
      - [Core - spring-security-core.jar](#core---spring-security-corejar)
      - [Remoting - spring-security-remoting.jar](#remoting---spring-security-remotingjar)
      - [Web - spring-security-web.jar](#web---spring-security-webjar)
      - [Config - spring-security-config.jar](#config---spring-security-configjar)
      - [LDAP - spring-security-ldap.jar](#ldap---spring-security-ldapjar)
      - [ACL - spring-security-acl.jar](#acl---spring-security-acljar)
      - [CAS - spring-security-cas.jar](#cas---spring-security-casjar)
      - [OpenID - spring-security-openid.jar](#openid---spring-security-openidjar)
      - [Test - spring-security-test.jar](#test---spring-security-testjar)
   - [2.4.4. 소스 Checkout 하기](#244-소스-checkout-하기)

#### [3. Spring Security 4.2의 새로운 점](#3-spring-security-42의-새로운-점-1)
- [3.1. 웹 개선사항](#31-웹-개선사항)
- [3.2. 설정 개선사항](#32-설정-개선사항)
- [3.3. 기타 새로운 점](#33-기타-새로운-점)

#### [4. 샘플과 가이드](#4-샘플과-가이드-1)

#### [5. Java 설정](#5-java-설정-1)
- [5.1. 웹 Security Java 설정](#51-웹-security-java-설정)
   - [5.1.1. AbstractSecurityWebApplicationInitializer](#511-abstractsecuritywebapplicationinitializer)
   - [5.1.2. AbstractSecurityWebApplicationInitializer (Spring을 사용하지 않는 경우)](#512-abstractsecuritywebapplicationinitializer-spring을-사용하지-않는-경우)
   - [5.1.3. AbstractSecurityWebApplicationInitializer (Spring MVC와 함께 사용하는 경우)](#513-abstractsecuritywebapplicationinitializer-spring-mvc와-함께-사용하는-경우)
- [5.2. HttpSecurity](#52-httpsecurity)
- [5.3. Java 설정과 Form 로그인](#53-java-설정과-form-로그인)
- [5.4. 권한 부여 요청 (Authorize Requests)](#54-권한-부여-요청-authorize-requests)
- [5.5. 로그아웃](#55-로그아웃)
   - [5.5.1. LogoutHandler](#551-logouthandler)
   - [5.5.2. LogoutSuccessHandler](#552-logoutsuccesshandler)
   - [5.5.3. 로그아웃 관련 참고사항](#553-로그아웃-관련-참고사항)
- [5.6. 인증 (Authentication)](#56-인증-authentication)
   - [5.6.1. 메모리를 이용한 인증 (In-Memory Authentication)](#561-메모리를-이용한-인증-in-memory-authentication)
   - [5.6.2. JDBC 인증 (JDBC Authentication)](#562-jdbc-인증-jdbc-authentication)
   - [5.6.3. LDAP 인증 (LDAP Authentication)](#563-ldap-인증-ldap-authentication)
   - [5.AuthenticationProvider](#564-authenticationprovider)
   - [5.6.5. UserDetailsService](#565-userdetailsservice)
- [5.7. 다중 HttpSecurity](#57-다중-httpsecurity)
- [5.8. 메서드 Security (Method Security)](#58-메서드-security-method-security)
   - [5.8.1. EnableGlobalMethodSecurity](#581-enableglobalmethodsecurity)
   - [5.8.2. GlobalMethodSecurityConfiguration](#582-globalmethodsecurityconfiguration)
- [5.9. 설정 객체의 수정/대체](#59-설정-객체의-수정대체)
- [5.10. DSL 커스터마이징하기](#510-dsl-커스터마이징하기)

#### [6. Security 네임스페이스 설정](#6-security-네임스페이스-설정-1)
- [6.1. 소개](#61-소개)
   - [6.1.1. 네임스페이스 설계](#611-네임스페이스-설계)
- [6.2. Security 네임스페이스 설정 시작하기](#62-security-네임스페이스-설정-시작하기)
   - [6.2.1. web.xml 설정](#621-webxml-설정)
   - [6.2.2. 최소한의 ```<http>``` 설정](#622-최소한의-http-설정)
   - [6.2.3. Form과 기본적인 로그인 옵션](#623-form과-기본적인-로그인-옵션)
      - [로그인 성공 후 전환되는 페이지 정보 설정](#로그인-성공-후-전환되는-페이지-정보-설정)
   - [6.2.4. 로그아웃 처리](#624-로그아웃-처리)
   - [6.2.5. 다른 인증 공급자 사용하기](#625-다른-인증-공급자-사용하기)
      - [비밀번호 암호화기(password encoder) 추가하기](#비밀번호-암호화기password-encoder-추가하기)
- [6.3. 고급 웹 기능](#63-고급-웹-기능)
   - [6.3.1. 인증 기억하기](#631-인증-기억하기)
   - [6.3.2. HTTP/HTTPS 채널 보안 추가하기](#632-httphttps-채널-보안-추가하기)
   - [6.3.3. 세션 관리하기](#633-세션-관리하기)
      - [Timeout 감지하기](#timeout-감지하기)
      - [동시 세션 제어하기](#동시-세션-제어하기)
      - [세션 강제고정 공격(Session Fixation Attack) 방어하기](#세션-강제고정-공격session-fixation-attack-방어하기)
   - [6.3.4. OpenID 지원](#634-openid-지원)
      - [속성 교환](#속성-교환)
   - [6.3.5. 응답 헤더](#635-응답-헤더)
   - [6.3.6. 사용자지정 Filter 추가하기](#636-사용자지정-filter-추가하기)
      - [사용자 지정 AuthenticationEntryPoint 설정하기](#사용자-지정-authenticationentrypoint-설정하기)
- [6.4. 메서드 Security](#64-메서드-security)
   - [6.4.1. ```<global-method-security>``` 요소](#641-global-method-security-요소)
      - [protect-pointcut을 사용하여 Security pointcut 추가하기](#protect-pointcut을-사용하여-security-pointcut-추가하기)
- [6.5. 기본 AccessDecisionManager](#65-기본-accessdecisionmanager)
   - [6.5.1. AccessDecisionManager 커스터마이징하기](#651-accessdecisionmanager-커스터마이징하기)
- [6.6. 인증 관리자(Authentication Manager)와 네임스페이스](#66-인증-관리자authentication-manager와-네임스페이스)

#### [7. 어플리케이션 샘플](#7-어플리케이션-샘플-1)
- [7.1. Tutorial 샘플 (기본)](#71-tutorial-샘플-기본)
- [7.2. Contacts 샘플 (고급)](#72-contacts-샘플-고급)
- [7.3. LDAP 샘플](#73-ldap-샘플)
- [7.4. OpenId 샘플](#74-openid-샘플)
- [7.5. CAS 샘플](#75-cas-샘플)
- [7.6. JAAS 샘플](#76-jaas-샘플)
- [7.7. 사전 인증(Pre-Authentication) 샘플](#77-사전-인증pre-authentication-샘플)

#### [8. Spring Security 커뮤니티](#8-spring-security-커뮤니티-1)
- [8.1. 이슈 트래킹](#81-이슈-트래킹)
- [8.2. 참여하기](#82-참여하기)
- [8.3. 추가적인 정보](#83-추가적인-정보)

### [[2] 아키텍처(Architecture)와 구현(Implementation)](#2-아키텍처architecture와-구현implementation-1)

#### [9. 기술 개요](#9-기술-개요-1)
- [9.1. 실행 환경](#91-실행-환경)
- [9.2. 핵심 요소](#92-핵심-요소)
   - [9.2.1. SecurityContextHoler, SecurityContext와 Authentication 객체](#921-securitycontextholer-securitycontext와-authentication-객체)
      - [현재 사용자에 대한 정보 얻기](#현재-사용자에-대한-정보-얻기)
   - [9.2.2. UerDetailsService](#922-uerdetailsservice)
   - [9.2.3. GrantedAuthority](#923-grantedauthority)
   - [9.2.4. 요약](#924-요약)
- [9.3. 인증 (Authentication)](#93-인증-authentication)
   - [9.3.1. Spring Security에서 인증(Authentication)이란 무엇인가?](#931-spring-security에서-인증authentication이란-무엇인가)
   - [9.3.2. SecurityContextHoler 내용 직접 설정하기](#932-securitycontextholer-내용-직접-설정하기)
- [9.4. 웹 어플리케이션에서의 인증(Authentication)](#94-웹-어플리케이션에서의-인증authentication)
   - [9.4.1. ExceptionTranslationFilter](#941-exceptiontranslationfilter)
   - [9.4.2. AuthenticationEntryPoint](#942-authenticationentrypoint)
   - [9.4.3. 인증 절차](#943-인증-절차)
   - [9.4.4. 요청(request)간의 SecurityContext 저장하기](#944-요청request간의-securitycontext-저장하기)
- [9.5. Spring Security에서의 접근제어(승인,Authorization)](#95-spring-security에서의-접근제어승인authorization)
   - [9.5.1. Security와 AOP](#951-security와-aop)
   - [9.5.2. 보안객체(Secure Object)와 AbstractSecurityInterceptor](#952-보안객체secure-object와-abstractsecurityinterceptor)
      - [설정 속성(Configuration Attributes)](#설정-속성configuration-attributes)
      - [RunAsManager](#runasmanager)
      - [AfterInvocationManager](#afterinvocationmanager)
      - [보안객체(Secure Object) 모델 확장하기](#보안객체secure-object-모델-확장하기)
- [9.6. 언어 설정(Localization)](#96-언어-설정localization)

#### [10. 핵심 서비스](#10-핵심-서비스-1)
- [10.1. AuthenticationManager, ProviderManager, AuthenticationProvider](#101-authenticationmanager-providermanager-authenticationprovider)
   - [10.1.1. 인증 성공 시 자격증명(Credentials) 지우기](#1011-인증-성공-시-자격증명credentials-지우기)
   - [10.1.2. aoAuthenticationProvider](#1012-aoauthenticationprovider)
- [10.2. UserDetailsService 구현](#102-userdetailsservice-구현)
   - [10.2.1. 메모리상 인증(In-Memory Authorization)](#1021-메모리상-인증in-memory-authorization)
   - [10.2.2. JdbcDaoImpl](#1022-jdbcdaoimpl)
      - [권한(Authority) 그룹](#권한authority-그룹)
- [10.3. 비밀번호 암호화](#103-비밀번호-암호화)
   - [10.3.1. hash란 무엇인가?](#1031-hash란-무엇인가)
   - [10.3.2. hash에 양념 추가하기](#1032-hash에-양념-추가하기)
   - [10.3.3. Hashing과 인증(Authentication)](#1033-hashing과-인증authentication)
- [10.4. Jackson 지원](#104-jackson-지원)

### [[3] 테스트](#3-테스트-1)

#### [11. 메서드 Security 테스트](#11-메서드-security-테스트-1)
- [11.1. Security Test 설치](#111-security-test-설치)
- [11.2. @WithMockUser](#112-withmockuser)
- [11.3. @WithAnonymousUser](#113-withanonymoususer)
- [11.4. @WithUserDetails](#114-withuserdetails)
- [11.5. @WithSecurityContext](#115-withsecuritycontext)
- [11.6. 메타 어노테이션(meta annotation) 테스트하기](#116-메타-어노테이션meta-annotation-테스트하기)

#### [12. Spring MVC 테스트](#12-spring-mvc-테스트-1)
- [12.1. MockMvc와 Spring Security 설치하기](#121-mockmvc와-spring-security-설치하기)
- [12.2. SecurityMockMvcRequestPostProcessors](#122-securitymockmvcrequestpostprocessors)
   - [12.2.1. CSRF 방어 테스트](#1221-csrf-방어-테스트)
   - [12.2.2. Spring MVC 테스트에서 사용자로서 테스트 수행하기](#1222-spring-mvc-테스트에서-사용자로서-테스트-수행하기)
   - [12.2.3. RequestPostProcessor를 사용한 Spring MVC 테스트에서 사용자로서 테스트 수행하기](#1223-requestpostprocessor를-사용한-spring-mvc-테스트에서-사용자로서-테스트-수행하기)
      - [어노테이션을 사용한 Spring MVC 테스트에서 사용자로서 테스트 수행하기](#어노테이션을-사용한-spring-mvc-테스트에서-사용자로서-테스트-수행하기)
   - [12.2.4. HTTP 기본 인증 테스트하기](#1224-http-기본-인증-테스트하기)
- [12.3. SecurityMockMvcRequestBuilders](#123-securitymockmvcrequestbuilders)
   - [12.3.1. Form 기반 인증 테스트하기](#1231-form-기반-인증-테스트하기)
   - [12.3.2. 로그아웃 테스트하기](#1232-로그아웃-테스트하기)
- [12.4. SecurityMockMvcResultMatchers](#124-securitymockmvcresultmatchers)
   - [12.4.1. 비인증 테스트 (Unauthenticated Assertion)](#1241-비인증-테스트-unauthenticated-assertion)
   - [12.4.2. 인증 테스트 (Authenticated Assertion)](#1242-인증-테스트-authenticated-assertion)

### [[4] 웹 어플리케이션 Security](#4-웹-어플리케이션-security-1)

#### [13. Security Filter Chain](#13-security-filter-chain-1)
- [13.1. DelegatingFilterProxy](#131-delegatingfilterproxy)
- [13.2. FilterChainProxy](#132-filterchainproxy)
   - [13.2.1. Filter Chain 우회하기](#1321-filter-chain-우회하기)
- [13.3. Filter 순서](#133-filter-순서)
- [13.4. 요청 매칭(Request Matching)과 HttpFirewall](#134-요청-매칭request-matching과-httpfirewall)
- [13.5. 다른 Filter 기반 프레임워크 함께 사용하기](#135-다른-filter-기반-프레임워크-함께-사용하기)
- [13.6. 고급 네임스페이스 설정](#136-고급-네임스페이스-설정)

#### [14. 핵심 Security Filter](#14-핵심-security-filter-1)
- [14.1. FilterSecurityInterceptor](#141-filtersecurityinterceptor)
- [14.2. ExceptionTranslationFilter](#142-exceptiontranslationfilter)
   - [14.2.1. AuthenticationEntryPoint](#1421-authenticationentrypoint)
   - [14.2.2. AccessDeniedHandler](#1422-accessdeniedhandler)
   - [14.2.3. Saved Request와 RequestCache 인터페이스](#1423-saved-request와-requestcache-인터페이스)
- [14.3. SecurityContextPersistenceFilter](#143-securitycontextpersistencefilter)
   - [14.3.1. SecurityContextPrepository](#1431-securitycontextprepository)
- [14.4. UsernamePasswordAuthenticationFilter](#144-usernamepasswordauthenticationfilter)
   - [14.4.1. 인증 성공/실패 시 어플리케이션의 흐름](#1441-인증-성공실패-시-어플리케이션의-흐름)

#### [15. Servlet API 통합](#15-servlet-api-통합-1)
- [15.1. Servlet 2.5+ 통합](#151-servlet-25-통합)
   - [15.1.1. HttpServletRequest.getRemoteUser()](#1511-httpservletrequestgetremoteuser)
   - [15.1.2. HttpServletRequest.getUserPrincipal()](#1512-httpservletrequestgetuserprincipal)
   - [15.1.3. HttpServletRequest.isUserInRole(String)](#1513-httpservletrequestisuserinrolestring)
- [15.2. Servlet 3+ 통합](#152-servlet-3-통합)
   - [15.2.1. HttpServletRequest.authenticate(HttpServletRequest, HttpServletResponse)](#1521-httpservletrequestauthenticatehttpservletrequest-httpservletresponse)
   - [15.2.2. HttpServletRequest.login(String, String)](#1522-httpservletrequestloginstring-string)
   - [15.2.3. HttpServletRequest.logout()](#1523-httpservletrequestlogout)
   - [15.2.4. AsyncContext.start(Runnable)](#1524-asynccontextstartrunnable)
   - [15.2.5. 비동기 Servlet 지원](#1525-비동기-servlet-지원)
- [15.3. Servlet 3.1+ 통합](#153-servlet-31-통합)
   - [15.3.1. HttpServletRequest.changeSessionId()](#1531-httpservletrequestchangesessionid)

#### [16. 기본 인증(Basic Authorization)과 다이제스트 인증(Digest Authorization)](#16-기본-인증basic-authorization과-다이제스트-인증digest-authorization-1)
- [16.1. BasicAuthenticationFilter](#161-basicauthenticationfilter)
   - [16.1.1. 설정](#1611-설정)
- [16.2. DigestAuthorizationFilter](#162-digestauthorizationfilter)
   - [16.2.1. 설정](#1621-설정)

#### [17. Remember-Me 인증(Authentication)](#17-remember-me-인증authentication-1)
- [17.1. 개요](#171-개요)
- [17.2. 단순 Hash기반 토큰(Token) 접근](#172-단순-hash기반-토큰token-접근)
- [17.3. 지속적인 토큰(Token) 접근](#173-지속적인-토큰token-접근)
- [17.4. Remember-Me 인터페이스와 구현](#174-remember-me-인터페이스와-구현)
   - [17.4.1. TokenBasedRememberMeServices](#1741-tokenbasedremembermeservices)
   - [17.4.2. PersistentTokenBasedRememberMeServices](#1742-persistenttokenbasedremembermeservices)

#### [18. 사이트간 요청 위조(Cross Site Request Forgery, CSRF)](#18-사이트간-요청-위조cross-site-request-forgery-csrf-1)
- [18.1. CSRF 공격](#181-csrf-공격)
- [18.2. Synchronizer 토큰 패턴(Synchronizer Token Pattern)](#182-synchronizer-토큰-패턴synchronizer-token-pattern)
- [18.3. CSRF 방어를 사용하는 경우](#183-csrf-방어를-사용하는-경우)
   - [18.3.1. CSRF 방어와 JSON](#1831-csrf-방어와-json)
   - [18.3.2. CSRF와 Stateless 브라우저 어플리케이션(Stateless Browser Application)](#1832-csrf와-stateless-브라우저-어플리케이션)
- [18.4. Spring Security CSRF 방어 사용하기](#184-spring-security-csrf-방어-사용하기)
   - [18.4.1. 적절한 HTTP 메서드 사용](#1841-적절한-http-메서드-사용)
   - [18.4.2. CSRF 방어 설정](#1842-csrf-방어-설정)
   - [18.4.3. CSRF 토큰 포함하기](#1843-csrf-토큰-포함하기)
      - [Form 전송](#form-전송)
      - [Ajax와 JSON 요청(Request)](#ajax와-json-요청request)
      - [CookieCsrfTokenRepository](#cookiecsrftokenrepository)
- [18.5. CSRF 주의사항](#185-csrf-주의사항)
   - [18.5.1. Timeout](#1851-timeout)
   - [18.5.2. 로그인하기](#1852-로그인하기)
   - [18.5.3. 로그아웃하기](#1853-로그아웃하기)
   - [18.5.4. Multipart(파일 업로드)](#1854-multipart파일-업로드)
      - [Spring Security 앞에 MultipartFilter 배치하기](#spring-security-앞에-multipartfilter-배치하기)
      - [Action에 CSRF 토큰 포함하기](#action에-csrf-토큰-포함하기)
   - [18.5.5. HiddenHttpMethodFilter](#1855-hiddenhttpmethodfilter)
- [18.6. 기본값 Override하기](#186-기본값-override하기)

#### [19. CORS](#19-cors-1)

#### [20. Security HTTP 응답헤더](#20-security-http-응답헤더-1)
- [20.1. 기본 Security 헤더](#201-기본-security-헤더)
   - [20.1.1. Cache 제어](#2011-cache-제어)
   - [20.1.2. Content Type 옵션](#2012-content-type-옵션)
   - [20.1.3. HTTP Strict Transport Security (HSTS)](#2013-http-strict-transport-security-hsts)
   - [20.1.4. HTTP Public Key Pinning (HPKP)](#2014-http-public-key-pinning-hpkp)
   - [20.1.5. X-Frame-Options](#2015-x-frame-options)
   - [20.1.6. X-XSS-Protection](#2016-x-xss-protection)
   - [20.1.7. Content Security Policy(CSP)](#2017-content-security-policycsp)
      - [Content Security Policy 설정하기](#content-security-policy-설정하기)
      - [추가적인 Resources](#추가적인-resources)
   - [20.1.8. Referrer Policy](#2018-referrer-policy)
      - [Refferer Policy 설정하기](#refferer-policy-설정하기)
- [20.2. 사용자정의 헤더](#202-사용자정의-헤더)
   - [20.2.1. Static Headers](#2021-static-headers)
   - [20.2.2. HeaderWriter](#2022-headerwriter)
   - [20.2.3. DelegatingRequestMatcherHeaderWriter](#2023-delegatingrequestmatcherheaderwriter)

#### [21. 세션 관리 (Session Management)](#21-세션-관리-session-management-1)
- [21.1. SessionManagementFilter](#211-sessionmanagementfilter)
- [20.2. SessionAuthenticationStrategy](#202-sessionauthenticationstrategy)
- [20.3. 동시성 제어(Concurrency Control)](#203-동시성-제어concurrency-control)
   - [20.3.1. 현재 인증된 사용자 및 해당 세션에 대한 SessionRegistry 질의하기(Querying)](#2031-현재-인증된-사용자-및-해당-세션에-대한-sessionregistry-질의하기querying)

#### [22. 익명 인증(Anonymous Authentication)](#22-익명-인증anonymous-authentication-1)
- [22.1. 개요](#221-개요)
- [22.2. 설정](#222-설정)
- [22.3. AuthenticationTrustResolver](#223-authenticationtrustresolver)

#### [23. WebSocket Security](#23-websocket-security-1)
- [23.1. WebSocket 설정](#231-websocket-설정)
- [23.2. WebSocket 인증(Authentication)](#232-websocket-인증authentication)
- [23.3. WebSocket 승인(Authorization)](#233-websocket-승인authorization)
   - [23.3.1. WebSocket 승인 알림](#2331-websocket-승인-알림)
      - [메시지 타입으로 WebSocket 승인](#메시지-타입으로-websocket-승인)
      - [목적지로 WebSocket 승인](#목적지로-websocket-승인)
   - [23.3.2. 아웃바운드 메시지(Outbound Messages)](#2332-아웃바운드-메시지outbound-messages)
- [23.4. 동일출처정책(SOP, Same Origin Policy) 적용하기](#234-동일출처정책sop-same-origin-policy-적용하기)
   - [23.4.1. 왜 같은 출처인가?](#2341-왜-같은-출처인가)
   - [23.4.2. 출처를 허용하는 Spring WebSocket](#2342-출처를-허용하는-spring-websocket)
   - [23.4.3. STOMP(Simple Text Oriented Massaging Protocol) 헤더에 CSRF 추가하기](#2343-stompsimple-text-oriented-massaging-protocol-헤더에-csrf-추가하기)
   - [23.4.4. WebSocket에서 CSRF 비활성화하기](#2344-websocket에서-csrf-비활성화하기)
- [23.5. SockJS와 함께 동작하기](#235-sockjs와-함께-동작하기)
   - [23.5.1. SockJS와 ```<frame-options>```](#2351-sockjs와-frame-options)
   - [23.5.2. SockJS와 CSRF 방어 수준 조정하기](#2352-sockjs와-csrf-방어-수준-조정하기)

### [[5] 승인(Authorization)](#5-승인authorization-1)

#### [24. 승인 아키텍처(Authorization Architecture)](#24-승인-아키텍처authorization-architecture-1)
- [24.1. 권한(Authorities)](#241-권한authorities)
- [24.2. 사전 호출 처리](#242-사전-호출-처리)
   - [24.2.1. AccessDecisionManager](#2421-accessdecisionmanager)
   - [24.2.2. 투표행위 기반 AccessDecisionManager 구현](#2422-투표행위-기반-accessdecisionmanager-구현)
      - [RoleVoter](#rolevoter)
      - [AuthenticatedVoter](#authenticatedvoter)
      - [사용자정의 Voter](#사용자정의-voter)
- [24.3. 호출 처리 이후](#243-호출-처리-이후)
- [24.4. 계층적인 구조를 가진 권한](#244-계층적인-구조를-가진-권한)

#### [25. 보안객체(Secure Object) 구현](#25-보안객체secure-object-구현-1)
- [25.1. AOP Alliance (MethodInvocation) Security Interceptor](#251-aop-alliance-methodinvocation-security-interceptor)
   - [25.1.1. Explicit MethodSecurityInterceptor 설정](#2511-explicit-methodsecurityinterceptor-설정)
- [25.2. AspectJ (JoinPoint) Security Interceptor](#252-aspectj-joinpoint-security-interceptor)

#### [26. 표현식 기반 접근 제어](#26-표현식-기반-접근-제어-1)
- [26.1. 개요](#261-개요)
   - [26.1.1. 일반적인 내장 표현식](#2611-일반적인-내장-표현식)
- [26.2. 웹 Security 표현식](#262-웹-security-표현식)
   - [26.2.1. 웹 Security 표현식 내에서 Bean 참조하기](#2621-웹-security-표현식-내에서-bean-참조하기)
   - [26.2.2. 웹 Security 표현식 내에서 URL 경로 변수 (Path Variables) 참조하기](#2622-웹-security-표현식-내에서-url-경로-변수-path-variables-참조하기)
- [26.3. 메서드 Security 표현식](#263-메서드-security-표현식)
   - [26.3.1. @Pre, @Post 어노테이션](#2631-pre-post-어노테이션)
      - [@PreAuthorize와 @PostAuthorize를 사용한 접근제어](#preauthorize와-postauthorize를-사용한-접근제어)
      - [@PreFilter와 @PostFilter를 사용한 필터링](#prefilter와-postfilter를-사용한-필터링)
   - [26.3.2. 내장 표현식](#2632-내장-표현식)
      - [PermissionEvaluator 인터페이스](#permissionevaluator-인터페이스)
      - [메서드 Security 메타 어노테이션(Meta Annotation)](#메서드-security-메타-어노테이션meta-annotation)

### [[6] 추가항목](#6-추가항목-1)

#### [27. 도메인 객체 Security(Domain Object Security) (ACLs)](#27-도메인-객체-securitydomain-object-security-acls-1)
- [27.1. 개요](#271-개요)
- [27.2. 키 개념](#272-키-개념)
- [27.3. 시작하기](#273-시작하기)

#### [28. 사전인증(Pre-Authentication) 시나리오](#28-사전인증pre-authentication-시나리오-1)
- [28.1. 사전인증(Pre-Authentication) 프레임워크 클래스](#281-사전인증pre-authentication-프레임워크-클래스)
   - [28.1.1. AbstractPreAuthenticatedProcessingFilter](#2811-abstractpreauthenticatedprocessingfilter)
      - [J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource](#j2eebasedpreauthenticatedwebauthenticationdetailssource)
   - [28.1.2. PreAuthenticatedAuthenticationProvider](#2812-preauthenticatedauthenticationprovider)
   - [28.1.3. Http403ForbiddenEntryPoint](#2813-http403forbiddenentrypoint)
- [28.2. 구체적인 구현체](#282-구체적인-구현체)
   - [28.2.1. 요청헤더 인증(Request-Header Authentication) (Siteminder)](#2821-요청헤더-인증request-header-authentication-siteminder)
      - [Siteminder 설정 예제](#siteminder-설정-예제)
   - [28.2.2. Java EE Container 인증(Authentication)](#2822-java-ee-container-인증authentication)

#### [29. LDAP 인증 (LDAP Authentication)](#29-ldap-인증-ldap-authentication-1)
- [29.1. 개요](#291-개요)
- [29.2. Spring Security와 함께 LDAP 사용하기](#292-spring-security와-함께-ldap-사용하기)
- [29.3. LDAP 서버 설정하기](#293-ldap-서버-설정하기)
   - [29.3.1. 내장 테스트 서버 사용하기](#2931-내장-테스트-서버-사용하기)
   - [29.3.2. 바인드 인증(Bind Authentication) 사용하기](#2932-바인드-인증bind-authentication-사용하기)
   - [29.3.3. 권한 불러오기(Loading Authorities)](#2933-권한-불러오기loading-authorities)
- [29.4. 구현 클래스들](#294-구현-클래스들)
   - [29.4.1. LdapAuthenticator 구현체](#2941-ldapauthenticator-구현체)
      - [공통 기능](#공통-기능)
      - [BindAuthenticator](#bindauthenticator)
      - [PasswordComparisonAuthenticator](#passwordcomparisonauthenticator)
   - [29.4.2. LDAP 서버에 연결하기](#2942-ldap-서버에-연결하기)
   - [29.4.3. LDAP 검색 객체](#2943-ldap-검색-객체)
      - [FilterBasedLdapUserSearch](#filterbasedldapusersearch)
   - [29.4.4. LdapAuthoritiesPopulator](#2944-ldapauthoritiespopulator)
   - [29.4.5. Spring Bean 설정](#2945-spring-bean-설정)
   - [29.4.6. LDAP 속성과 사용자정의 UserDeatils](#2946-ldap-속성과-사용자정의-userdeatils)
- [29.5. 유효한 디렉토리 인증(Active Directory Authentication)](#295-유효한-디렉토리-인증active-directory-authentication)
   - [29.5.1. ActiveDirectoryLdapAuthenticationProvider](#2951-activedirectoryldapauthenticationprovider)
      - [유효한 디렉토리 에러 코드](#유효한-디렉토리-에러-코드)

#### [30. JSP 태그 라이브러리](#30-jsp-태그-라이브러리-1)
- [30.1. Taglib 선언하기](#301-taglib-선언하기)
- [30.2. 권한부여 태그 ```authorize```](#302-권한부여-태그-authorize)
   - [30.2.1. 테스팅을 위한 태그 인증 비활성화하기](#3021-테스팅을-위한-태그-인증-비활성화하기)
- [30.3. 인증 태그 ```authentication```](#303-인증-태그-authentication)
- [30.4. 접근제어 태그 ```accesscontrollist```](#304-접근제어-태그-accesscontrollist)
- [30.5. CSRF입력 태그 ```csrfInput```](#305-csrf입력-태그-csrfinput)
- [30.6. CSRF메타 태그 ```csrfMetaTags```](#306-csrf메타-태그-csrfmetatags)

#### [31. Java Authentication and Authorization Service (JAAS) Provider](#31-java-authentication-and-authorization-service-jaas-provider-1)
- [31.1. 개요](#311-개요)
- [31.2. AbstractJaasAuthenticationProvider](#312-abstractjaasauthenticationprovider)
   - [31.2.1. JAAS CallbackHandler](#3121-jaas-callbackhandler)
   - [31.2.2. JAAS AuthorityGranter](#3122-jaas-authoritygranter)
- [31.3. DefaultJaasAuthenticationProvider](#313-defaultjaasauthenticationprovider)
   - [31.3.1. InMemoryConfiguration](#3131-inmemoryconfiguration)
   - [31.3.2. DefaultJaasAuthenticationProvider 설정 예제](#3132-defaultjaasauthenticationprovider-설정-예제)
- [31.4. JaasAuthenticationProvider](#314-jaasauthenticationprovider)
- [31.5. Subject 객체로 실행하기](#315-subject-객체로-실행하기)

#### [32. CAS 인증(CAS Authentication)](#32-cas-인증cas-authentication-1)
- [32.1. 개요](#321-개요)
- [32.2. CAS인증은 어떻게 동작하는가?](#322-cas인증은-어떻게-동작하는가)
   - [32.2.1. Spring Security와 CAS 상호작용 과정](#3221-spring-security와-cas-상호작용-과정)
- [32.3. CAS 클라이언트 설정](#323-cas-클라이언트-설정)
   - [32.3.1. Service Ticket 인증(Authentication)](#3231-service-ticket-인증authentication)
   - [32.3.2. Single Logout](#3232-single-logout)
   - [32.3.3. CAS로 Stateless 서비스 인증하기](#3233-cas로-stateless-서비스-인증하기)
      - [Ticket이 부여된 Proxy를 얻기 위해 CAS 설정하기](#ticket이-부여된-proxy를-얻기-위해-cas-설정하기)
      - [Proxy Ticket 사용하여 Stateless 서비스 부르기](#proxy-ticket-사용하여-stateless-서비스-부르기)
   - [32.3.4. Proxy Ticket 인증(Authentication)](#3234-proxy-ticket-인증authentication)

#### [33. X.509 인증(Authentication)](#33-x509-인증authentication-1)
- [33.1. 개요](#331-개요)
- [33.2. 웹서비스에 X.509 인증 추가하기](#332-웹서비스에-x509-인증-추가하기)
- [33.3. Tomcat에 SSL 설치하기](#333-tomcat에-ssl-설치하기)

#### [34. 보안객체(Secure Object) 콜백단계에서 인증(Authentication) 교체하기](#34-보안객체secure-object-콜백단계에서-인증authentication-교체하기-1)
- [34.1. 개요](#341-개요)
- [34.2. 설정](#342-설정)

#### [35. Spring Security 암호화 모듈](#35-spring-security-암호화-모듈-1)
- [35.1. 소개](#351-소개)
- [35.2. 암호화기(Encryptors)](#352-암호화기encryptors)
   - [35.2.1. BytesEncryptor](#3521-bytesencryptor)
   - [35.2.2. TextEncryptor](#3522-textencryptor)
- [35.3. 키 생성기(Key Generator)](#353-키-생성기key-generator)
   - [35.3.1. BytesKeyGenerator](#3531-byteskeygenerator)
   - [35.3.2. StringKeyGenerator](#3532-stringkeygenerator)
- [35.4. 비밀번호 인코딩하기](#354-비밀번호-인코딩하기)

#### [36. 동시성 지원](#36-동시성-지원-1)
- [36.1. DelegatingSecurityContextRunnable](#361-delegatingsecuritycontextrunnable)
- [36.2. DelegatingSecurttyContextExecutor](#362-delegatingsecurttycontextexecutor)
- [36.3. Spring Security 동시성 클래스들](#363-spring-security-동시성-클래스들)

#### [37. Spring MVC와의 통합](#37-spring-mvc와의-통합-1)
- [37.1. @EnableWebMvcSecurity](#371-enablewebmvcsecurity)
- [37.2. MvcRequestMatcher](#372-mvcrequestmatcher)
- [37.3. @AuthenticationPrincipal](#373-authenticationprincipal)
- [37.4. Spring MVC Async와의 통합](#374-spring-mvc-async와의-통합)
- [37.5. Spring MVC와 CSRF와의 통합](#375-spring-mvc와-csrf와의-통합)
   - [37.5.1. CSRF 토큰 자동 포함](#3751-csrf-토큰-자동-포함)
   - [37.5.2. CsrfToken 확인하기](#3752-csrftoken-확인하기)

### [[7] Spring Data와의 통합](#7-spring-data와의-통합-1)

#### [38. Spring Data와 Spring Security 설정](#38-spring-data와-spring-security-설정-1)

#### [39. @Query에서의 Security 표현식](#39-query에서의-security-표현식-1)

### [[8] 부록](#8-부록-1)

#### [40. Security Database Schema](#40-security-database-schema-1)
- [40.1. User Schema](#401-user-schema)
   - [40.1.1. Group 인증](#4011-group-인증)
- [40.2. 로그인 지속 스키마 (Persistent Login/Remember-Me Schema)](#402-로그인-지속-스키마-persistent-loginremember-me-schema)
- [40.3. ACL 스키마](#403-acl-스키마)
   - [40.3.1. HyperSQL](#4031-hypersql)
   - [40.3.2. PostgreSQL](#4032-postgresql)
   - [40.3.3. MySQL와 MariaDB](#4033-mysql와-mariadb)
   - [40.3.4. Microsoft SQL Server](#4034-microsoft-sql-server)
   - [40.3.5. Oracle](#4035-oracle)

#### [41. Security 네임스페이스](#41-security-네임스페이스-1)
- [41.1. 웹 어플리케이션 Security](#411-웹-어플리케이션-security)
   - [41.1.1. ```<debug>```](#4111-debug)
   - [41.1.2. ```<http>```](#4112-http)
      - [```<http>``` 속성](#http-속성)
      - [```<http>``` 하위요소](#http-하위요소)
   - [41.1.3. ```<access-denied-handler>```](#4113-access-denied-handler)
      - [```<access-denied_handler>``` 상위 요소](#access-denied_handler-상위-요소)
      - [```<access-denied_handler>``` 속성](#access-denied_handler-속성)
   - [41.1.4. ```<cors>```](#4114-cors)
      - [```<cors>``` 속성](#cors-속성)
      - [```<cors>``` 상위 요소](#cors-상위-요소)
   - [41.1.5. ```<headers>```](#4115-headers)
      - [```<headers>``` 속성](#headers-속성)
      - [```<headers>``` 상위 요소](#headers-상위-요소)
      - [```<headers>``` 하위 요소](#headers-하위-요소)
   - [41.1.6. ```<cache-control>```](#4116-cache-control)
      - [```<cache-controle>``` 속성](#cache-controle-속성)
      - [```<cache-controle>``` 상위 요소](#cache-controle-상위-요소)
   - [41.1.7. ```<hsts>```](#4117-hsts)
      - [```<hsts>``` 속성](#hsts-속성)
      - [```<hsts>``` 상위 요소](#hsts-상위-요소)
   - [41.1.8. ```<hpkp>```](#4118-hpkp)
      - [```<hpkp>``` 속성](#hpkp-속성)
      - [```<hpkp>``` 상위 요소](#hpkp-상위-요소)
   - [41.1.9. ```<pins>```](#4119-pins)
      - [```<pins>``` 하위 요소](#pins-하위-요소)
   - [41.1.10. ```<pin>```](#41110-pin)
      - [```<pin>``` 속성](#pin-속성)
      - [```<pin>``` 상위 요소](#pin-상위-요소)
   - [41.1.11. ```<content-security-policy>```](#41111-content-security-policy)
      - [```<content-security-policy>``` 속성](#content-security-policy-속성)
      - [```<content-security-policy>``` 상위 요소](#content-security-policy-상위-요소)
   - [41.1.12. ```<referrer-policy>```](#41112-referrer-policy)
      - [```<referrer-policy>``` 속성](#referrer-policy-속성)
      - [```<referrer-policy>``` 상위 요소](#referrer-policy-상위-요소)
   - [41.1.13. ```<frame-options>```](#referrer-policy-상위-요소)
      - [```<frame-options>``` 속성](#frame-options-속성)
      - [```<frame-options>``` 상위 요소](#frame-options-상위-요소)
   - [41.1.14. ```<xss-protection>```](#41114-xss-protection)
      - [```<xss-protection>``` 속성](#xss-protection-속성)
      - [```<xss-protection>``` 상위 요소](#xss-protection-상위-요소)
   - [41.1.15. ```<content-type-option>```](#41115-content-type-option)
      - [```<content-type-option>``` 속성](#content-type-option-속성)
      - [```<content-type-option>``` 상위 요소](#content-type-option-상위-요소)
   - [41.1.16. ```<header>```](#41116-header)
      - [```<header>``` 속성](#header-속성)
      - [```<header>``` 상위 요소](#header-상위-요소)
   - [41.1.17. ```<anonymous>```](#41117-anonymous)
      - [```<anonymous>``` 상위 요소](#anonymous-상위-요소)
      - [```<anonymous>``` 속성](#anonymous-속성)
   - [41.1.18. ```<csrf>```](#41118-csrf)
      - [```<csrf>``` 상위 요소](#csrf-상위-요소)
      - [```<csrf>``` 속성](#csrf-속성)
   - [41.1.19. ```<custom-filter>```](#41119-custom-filter)
      - [```<custom-filter>``` 상위 요소](#custom-filter-상위-요소)
      - [```<custom-filter>``` 속성](#custom-filter-속성)
   - [41.1.20. ```<expression-handler>```](#41120-expression-handler)
      - [```<expression-handler>``` 상위 요소](#expression-handler-상위-요소)
      - [```<expression-handler>``` 속성](#expression-handler-속성)
   - [41.1.21. ```<form-login>```](#41121-form-login)
      - [```<form-login>``` 상위 요소](#form-login-상위-요소)
      - [```<form-login>``` 속성](#form-login-속성)
   - [41.1.22. ```<http-basic>```](#41122-http-basic)
      - [```<http-basic>``` 상위 요소](#http-basic-상위-요소)
      - [```<http-basic>``` 속성](#http-basic-속성)
   - [41.1.23. ```<http-firewall>```](#41123-http-firewall)
      - [```<http-firewall>``` 속성](#http-firewall-속성)
   - [41.1.24. ```<intercept-url>```](#41124-intercept-url)
      - [```<intercept-url>``` 상위 요소](#intercept-url-상위-요소)
      - [```<intercept-url>``` 속성](#intercept-url-속성)
   - [41.1.25. ```<jee>```](#41125-jee)
      - [```<jee>``` 상위 요소](#jee-상위-요소)
      - [```<jee>``` 속성](#jee-속성)
   - [41.1.26. ```<logout>```](#41126-logout)
      - [```<logout>``` 상위 요소](#logout-상위-요소)
      - [```<logout>``` 속성](#logout-속성)
   - [41.1.27. ```<openid-login>```](#41127-openid-login)
      - [```<openid-login>``` 상위 요소](#openid-login-상위-요소)
      - [```<openid-login>``` 속성](#openid-login-속성)
      - [```<openid-login>``` 하위 요소](#openid-login-하위-요소)
   - [41.1.28. ```<attribute-exchange>```](#41128-attribute-exchange)
      - [```<attribute-exchange>``` 상위 요소](#attribute-exchange-상위-요소)
      - [```<attribute-exchange>``` 속성](#attribute-exchange-속성)
      - [```<attribute-exchange>``` 하위 요소](#attribute-exchange-하위-요소)
   - [41.1.29. ```<openid-attribute>```](#41129-openid-attribute)
      - [```<openid-attribute>``` 상위 요소](#openid-attribute-상위-요소)
      - [```<openid-attribute>``` 속성](#openid-attribute-속성)
   - [41.1.30. ```<port-mappings>```](#41130-port-mappings)
      - [```<port-mappings>``` 상위 요소](#port-mappings-상위-요소)
      - [```<port-mappings>``` 속성](#port-mappings-속성)
   - [41.1.31. ```<port-mapping>```](#41131-port-mapping)
      - [```<port-mapping>``` 상위 요소](#port-mapping-상위-요소)
      - [```<port-mapping>``` 속성](#port-mapping-속성)
   - [41.1.32. ```<remember-me>```](#41132-remember-me)
      - [```<remember-me>``` 상위 요소](#remember-me-상위-요소)
      - [```<remember-me>``` 속성](#remember-me-속성)
   - [41.1.33. ```<request-cache>```](#41133-request-cache)
      - [```<request-cache>``` 상위 요소](#request-cache-상위-요소)
      - [```<request-cache>``` 속성](#request-cache-속성)
   - [41.1.34. ```<session-management>```](#41134-session-management)
      - [```<session-management>``` 상위 요소](#session-management-상위-요소)
      - [```<session-management>``` 속성](#session-management-속성)
      - [```<session-management>``` 하위 요소](#session-management-하위-요소)
   - [41.1.35. ```<concurrency-control>```](#41135-concurrency-control)
      - [```<concurrency-control>``` 상위 요소](#concurrency-control-상위-요소)
      - [```<concurrency-control>``` 속성](#concurrency-control-속성)
   - [41.1.36. ```<x509>```](#41136-x509)
      - [```<x509>``` 상위 요소](#x509-상위-요소)
      - [```<x509>``` 속성](#x509-속성)
   - [41.1.37. ```<filter-chain-map>```](#41137-filter-chain-map)
      - [```<filter-chain-map>``` 속성](#filter-chain-map-속성)
      - [```<filter-chain-map>``` 하위 요소](#filter-chain-map-하위-요소)
   - [41.1.38. ```<filter-chain>```](#41138-filter-chain)
      - [```<filter-chain>``` 상위 요소](#filter-chain-상위-요소)
      - [```<filter-chain>``` 속성](#filter-chain-속성)
   - [41.1.39. ```<filter-security-metadata-source>```](#41139-filter-security-metadata-source)
      - [```<filter-security-metadata-source>``` 속성](#filter-security-metadata-source-속성)
      - [```<filter-security-metadata-source>``` 하위 요소](#filter-security-metadata-source-하위-요소)
- [41.2. WebSocket Security](#412-websocket-security)
   - [41.2.1. ```<websocket-message-broker>```](#4121-websocket-message-broker)
      - [```<websocket-message-broker>``` 속성](#websocket-message-broker-속성)
      - [```<websocket-message-broker>``` 하위 요소](#websocket-message-broker-하위-요소)
   - [41.2.2. ```<intercept-message>```](#4122-intercept-message)
      - [```<intercept-message>``` 상위 요소](#intercept-message-상위-요소)
      - [```<intercept-message>``` 속성](#intercept-message-속성)
- [41.3. 인증(Authentication) Services](#413-인증authentication-services)
   - [41.3.1. ```<authentication-manager>```](#4131-authentication-manager)
      - [```<authentication-manager>``` 속성](#authentication-manager-속성)
      - [```<authentication-manager>``` 하위 요소](#authentication-manager-하위-요소)
   - [41.3.2. ```<authentication-provider>```](#4132-authentication-provider)
      - [```<authentication-provider>``` 상위 요소](#authentication-provider-상위-요소)
      - [```<authentication-provider>``` 속성](#authentication-provider-속성)
      - [```<authentication-provider>``` 하위 요소](#authentication-provider-하위-요소)
   - [41.3.3. ```<jdbc-user-service>```](#4133-jdbc-user-service)
      - [```<jdbc-user-service>``` 속성](#jdbc-user-service-속성)
   - [41.3.4. ```<password-encoder>```](#4134-password-encoder)
      - [```<password-encoder>``` 상위 요소](#password-encoder-상위-요소)
      - [```<password-encoder>``` 속성](#password-encoder-속성)
      - [```<password-encoder>``` 하위 요소](#password-encoder-하위-요소)
   - [41.3.5. ```<salt-source>```](#4135-salt-source)
      - [```<salt-source>``` 상위 요소](#salt-source-상위-요소)
      - [```<salt-source>``` 속성](#salt-source-속성)
   - [41.3.6. ```<user-service>```](#4136-user-service)
      - [```<user-service>``` 속성](#user-service-속성)
      - [```<user-service>``` 하위 요소](#user-service-하위-요소)
   - [41.3.7. ```<user>```](#4137-user)
      - [```<user>``` 상위 요소](#user-상위-요소)
      - [```<user>``` 속성](#user-속성)
- [41.4. 메서드 Security](#414-메서드-security)
   - [41.4.1. ```<global-method-security>```](#4141-global-method-security)
      - [```<global-method-security>``` 속성](#global-method-security-속성)
      - [```<global-method-security>``` 하위 요소](#global-method-security-하위-요소)
   - [41.4.2. ```<after-invocation-provider>```](#4142-after-invocation-provider)
      - [```<after-invocation-provider>``` 상위 요소](#after-invocation-provider-상위-요소)
      - [```<after-invocation-provider>``` 속성](#after-invocation-provider-속성)
   - [41.4.3. ```<pre-post-annotation-handling>```](#4143-pre-post-annotation-handling)
      - [```<pre-post-annotation-handling>``` 상위 요소](#pre-post-annotation-handling-상위-요소)
      - [```<pre-post-annotation-handling>``` 하위 요소](#pre-post-annotation-handling-하위-요소)
   - [41.4.4. ```<invocation-attribute-factory>```](#4144-invocation-attribute-factory)
      - [```<invocation-attribute-factory>``` 상위 요소](#invocation-attribute-factory-상위-요소)
      - [```<invocation-attribute-factory>``` 속성](#invocation-attribute-factory-속성)
   - [41.4.5. ```<post-invocation-advice>```](#4145-post-invocation-advice)
      - [```<post-invocation-advice>``` 상위 요소](#post-invocation-advice-상위-요소)
      - [```<post-invocation-advice>``` 속성](#post-invocation-advice-속성)
   - [41.4.6. ```<pre-invocation-advice>```](#4146-pre-invocation-advice)
      - [```<pre-invocation-advice>``` 상위 요소](#pre-invocation-advice-상위-요소)
      - [```<pre-invocation-advice>``` 속성](#pre-invocation-advice-속성)
   - [41.4.7. ```<protect-pointcut>```](#4147-protect-pointcut)
      - [```<protect-pointcut>``` 상위 요소](#protect-pointcut-상위-요소)
      - [```<protect-pointcut>``` 속성](#protect-pointcut-속성)
   - [41.4.8. ```<intercept-methods>```](#4148-intercept-methods)
      - [```<intercept-methods>``` 속성](#intercept-methods-속성)
      - [```<intercept-methods>``` 하위 요소](#intercept-methods-하위-요소)
   - 4[1.4.9. ```<method-security-metadata-source>```](#4149-method-security-metadata-source)
      - [```<method-security-metadata-source>``` 속성](#method-security-metadata-source-속성)
      - [```<method-security-metadata-source>``` 하위 요소](#method-security-metadata-source-하위-요소)
   - [41.4.10. ```<protect>```](#41410-protect)
      - [```<protect>``` 상위 요소](#protect-상위-요소)
      - [```<protect>``` 속성](#protect-속성)
- [41.5. LDAP 네임스페이스 옵션](#415-ldap-네임스페이스-옵션)
   - [41.5.1. ```<ldap-server>```](#4151-ldap-server)
      - [```<ldap-server>``` 속성](#ldap-server-속성)
   - [41.5.2. ```<ldap-authentication-provider>```](#4152-ldap-authentication-provider)
      - [```<ldap-authentication-provider>``` 상위 요소](#ldap-authentication-provider-상위-요소)
      - [```<ldap-authentication-provider>``` 속성](#ldap-authentication-provider-속성)
      - [```<ldap-authentication-provider>``` 하위 요소](#ldap-authentication-provider-하위-요소)
   - [41.5.3. ```<password-compare>```](#4153-password-compare)
      - [```<password-compare>``` 상위 요소](#password-compare-상위-요소)
      - [```<password-compare>``` 속성](#password-compare-속성)
      - [```<password-compare>``` 하위 요소](#password-compare-하위-요소)
   - [41.5.4. ```<ldap-user-service>```](#4154-ldap-user-service)
      - [```<ldap-user-service>``` 속성](#ldap-user-service-속성)

#### [42. Spring Security 의존성 (Dependencies)](#42-spring-security-의존성-dependencies-1)
- [42.1. spring-security-core](#421-spring-security-core)
- [42.2. spring-security-remoting](#422-spring-security-remoting)
- [42.3. spring-security-web](#423-spring-security-web)
- [42.4. spring-security-ldap](#424-spring-security-ldap)
- [42.5. spring-security-config](#425-spring-security-config)
- [42.6. spring-security-acl](#426-spring-security-acl)
- [42.7. spring-security-cas](#427-spring-security-cas)
- [42.8. spring-security-openid](#428-spring-security-openid)
- [42.9. spring-security-taglibs](#429-spring-security-taglibs)

#### [43. 프록시(Proxy) 서버 설정](#43-프록시proxy-서버-설정-1)

#### [44. Spring Security FAQ (자주 찾는 질문)](#44-spring-security-faq-자주-찾는-질문-1)
- [44.1. 일반적인 질문](#441-일반적인-질문)
   - [44.1.1. Spring Security가 모든 어플리케이션 보안 요구 사항을 처리하는가?](#4411-spring-security가-모든-어플리케이션-보안-요구-사항을-처리하는가)
   - [44.1.2. 왜 web.xml security를 사용하지 않는가?](#4412-왜-webxml-security를-사용하지-않는가)
   - [44.1.3. Spring Security 적용을 위해 필요한 Java 및 Spring Framework 버전은 무엇인가?](#4413-spring-security-적용을-위해-필요한-java-및-spring-framework-버전은-무엇인가)
   - [44.1.4. Spring Security를 처음 접한 입장에서 HTTPS를 통해 CAS Single Sign-On을 지원하는 어플리케이션을 구축해야 한다. 이 어플리케이션은 특정 URL에 대해 로컬 인증을 허용하고 여러 최종 사용자 정보 출처(LDAP및 JDBC)에 대해 인증한다. 설정 파일을 찾아 복사했지만 제대로 작동하지 않는다. 무엇이 잘못된 것인가?](#4414-spring-security를-처음-접한-입장에서-https를-통해-cas-single-sign-on을-지원하는-어플리케이션을-구축해야-한다-이-어플리케이션은-특정-url에-대해-로컬-인증을-허용하고-여러-최종-사용자-정보-출처ldap및-jdbc에-대해-인증한다-설정-파일을-찾아-복사했지만-제대로-작동하지-않는다-무엇이-잘못된-것인가)
- [44.2. 일반적인 문제](#442-일반적인-문제)
   - [44.2.1. 로그인을 시도하면 "잘못된 자격증명(Bad Credentials)"이라는 오류 메시지가 표시된다. 무엇이 문제인가?](#4421-로그인을-시도하면-잘못된-자격증명bad-credentials이라는-오류-메시지가-표시된다-무엇이-문제인가)
   - [44.2.2. 로그인을 시도하면 어플리케이션이 무한 루프에 빠진다. 무슨 현상인가?](#4422-로그인을-시도하면-어플리케이션이-무한-루프에-빠진다-무슨-현상인가)
   - [44.2.3. "엑세스가 거부되었습니다(사용자는 익명)"라는 메시지와 함께 예외가 발생한다. 무엇이 문제인가?](#4423-엑세스가-거부되었습니다사용자는-익명라는-메시지와-함께-예외가-발생한다-무엇이-문제인가)
   - [44.2.4. 어플리케이션에서 로그아웃한 후에도 보안 페이지가 계속 표시되는 이유가 무엇인가?](#4424-어플리케이션에서-로그아웃한-후에도-보안-페이지가-계속-표시되는-이유가-무엇인가)
   - [44.2.5. "SecurityContext에서 인증 객체를 찾을 수 없습니다"라는 메시지와 함께 예외가 발생한다. 무엇이 문제인가?](#4425-securitycontext에서-인증-객체를-찾을-수-없습니다라는-메시지와-함께-예외가-발생한다-무엇이-문제인가)
   - [44.2.6. LDAP 인증이 작동하지 않는다. 설정에 무슨 문제가 있나?](#4426-ldap-인증이-작동하지-않는다-설정에-무슨-문제가-있나)
   - [44.2.7. 세션 관리](#4427-세션-관리)
   - [44.2.8. 사용자가 한번에 두 번 이상 로그인할 수 없게 하기 위해서 Spring Security의 동시 세션 제어를 사용하는 중이다. 하지만 로그인을 한 후에 다른 브라우저 창을 열어 로그인을 시도 하는 것은 막을 수가 없다. 이런 경우 왜 두 번 이상의 로그인이 가능한 것인가?](#4428-사용자가-한번에-두-번-이상-로그인할-수-없게-하기-위해서-spring-security의-동시-세션-제어를-사용하는-중이다-하지만-로그인을-한-후에-다른-브라우저-창을-열어-로그인을-시도-하는-것은-막을-수가-없다-이런-경우-왜-두-번-이상의-로그인이-가능한-것인가)
   - [44.2.9. Spring Security를 통해 인증할 때 왜 세션 아이디가 변경되는가?](#4429-spring-security를-통해-인증할-때-왜-세션-아이디가-변경되는가)
   - [44.2.10. Tomcat (또는 다른 서블릿 컨테이너)를 사용하는 중이며 로그인 페이지에서 HTTPS를 사용하도록 설정하였다.(로그인 이후에는 HTTP로 전환된다.) 그러나 제대로 작동하지 않는다. 인증 후 로그인 페이지로 돌아간다.](#44210-tomcat-또는-다른-서블릿-컨테이너를-사용하는-중이며-로그인-페이지에서-https를-사용하도록-설정하였다로그인-이후에는-http로-전환된다-그러나-제대로-작동하지-않는다-인증-후-로그인-페이지로-돌아간다)
   - [44.2.11. HTTP와 HTTPS 간 전환을 하지 않음에도 불구하고 세션이 여전히 손실된다.](#44211-http와-https-간-전환을-하지-않음에도-불구하고-세션이-여전히-손실된다)
   - [44.2.12. 동시 세션 제어를 사용하고 로그아웃을 했으며 허용된 세션을 초과하지 않았음에도 불구하고 로그인이 되지 않는다.](#44212-동시-세션-제어를-사용하고-로그아웃을-했으며-허용된-세션을-초과하지-않았음에도-불구하고-로그인이-되지-않는다)
   - [44.2.13. 세션을 생성하지 않도록 create-session 속성을 naver로 설정했음에도 불구하고 어느순간 세션을 생성한다.](#44213-세션을-생성하지-않도록-create-session-속성을-naver로-설정했음에도-불구하고-어느순간-세션을-생성한다)
   - [44.2.14. POST 실행할 때 403 Forbidden이 발생한다.](#44214-post-실행할-때-403-forbidden이-발생한다)
   - [44.2.15. RequestDispatcher를 사용하여 다른 URL로 요청을 전달하였는데 보안 제한조건이 적용되지 않는다.](#44215-requestdispatcher를-사용하여-다른-url로-요청을-전달하였는데-보안-제한조건이-적용되지-않는다)
   - [44.2.16. Spring Security ```<global-method-security>```요소를 어플리케이션 Context에 추가했지만 Spring MVC Controller bean(Struts action 등)에 security 어노테이션을 추가하면 그 어노테이션은 영향을 미치지 않는 것 같다.](#44216-spring-security-global-method-security요소를-어플리케이션-context에-추가했지만-spring-mvc-controller-beanstruts-action-등에-security-어노테이션을-추가하면-그-어노테이션은-영향을-미치지-않는-것-같다)
   - [44.2.17. 확실하게 인증된 사용자이지만 일부 요청중에 SecurityContextHolder에 접근하려고 하면 인증이 null값이다. 사용자 정보를 볼 수 없는 이유는 무엇인가?](#44217-확실하게-인증된-사용자이지만-일부-요청중에-securitycontextholder에-접근하려고-하면-인증이-null값이다-사용자-정보를-볼-수-없는-이유는-무엇인가)
   - [44.2.18. ```authorize``` JSP 태그는 URL 속성을 사용할 때 메서드 Security 어노테이션을 무시한다.](#44218-authorize-jsp-태그는-url-속성을-사용할-때-메서드-security-어노테이션을-무시한다)
- [44.3. 아키텍처(Architecture) 관련 질문](#443-아키텍처architecture-관련-질문)
   - [44.3.1. 각각의 클래스들이 어떤 패키지에 있는지 어떻게 알 수 있는가?](#4431-각각의-클래스들이-어떤-패키지에-있는지-어떻게-알-수-있는가)
   - [44.3.2. 네임스페이스 요소는 기존 Bean 설정에 어떻게 매핑되는가?](#4432-네임스페이스-요소는-기존-bean-설정에-어떻게-매핑되는가)
   - [44.3.3. "ROLE_"은 무엇을 의미하며 권한 이름이 왜 필요한가?](#4433-role_은-무엇을-의미하며-권한-이름이-왜-필요한가)
   - [44.3.4. Spring Security로 작업하기 위해서 어떤 종속성들을 추가해야 하는지 어떻게 알 수 있는가?](#4434-spring-security로-작업하기-위해서-어떤-종속성들을-추가해야-하는지-어떻게-알-수-있는가)
   - [44.3.5. 임베디드 ApacheDS LDAP 서버를 실행하려면 어떤 의존성이 필요한가?](#4435-임베디드-apacheds-ldap-서버를-실행하려면-어떤-의존성이-필요한가)
   - [44.3.6. UserDetailsService란 무엇이며 필요한 것인가?](href="#4436-userdetailsservice란-무엇이며-필요한-것인가")
- [44.4. 일반적인 방법에 관한 요청](#444-일반적인-방법에-관한-요청)
   - [44.4.1. 사용자 이름(username)보다 자세한 정보를 통해 로그인하도록 하고 싶다. 예를 들어, '회사이름'과 같은 새로운 로그인 필드를 추가하려면 어떻게 해야 하는가?](#4441-사용자-이름username보다-자세한-정보를-통해-로그인하도록-하고-싶다-예를-들어-회사이름과-같은-새로운-로그인-필드를-추가하려면-어떻게-해야-하는가)
   - [44.4.2. 요청 URL의 프래그먼트(#) 값만 다른 경우 (예: /foo#bar, /foo#blah) 다른 intercept-url 제약조건을 적용하려면 어떻게 해야 하는가?](#4442-요청-url의-프래그먼트-값만-다른-경우-예-foobar-fooblah-다른-intercept-url-제약조건을-적용하려면-어떻게-해야-하는가)
   - [44.4.3. UserDetailsService 내에 사용자 IP 주소(또는 다른 웹 요청 데이터) 정보에 접근하려면 어떻게 해야 하는가?](#4443-userdetailsservice-내에-사용자-ip-주소또는-다른-웹-요청-데이터-정보에-접근하려면-어떻게-해야-하는가)
   - [44.4.4. UserDetailsService에서 HttpSession를 접근하려면 어떻게 해야 하는가?](#4444-userdetailsservice에서-httpsession를-접근하려면-어떻게-해야-하는가)
   - [44.4.5. UserDetailsService 내에서 사용자 비밀번호에 접근하려면 어떻게 해야 하는가?](#4445-userdetailsservice-내에서-사용자-비밀번호에-접근하려면-어떻게-해야-하는가)
   - [44.4.6. 어플리케이션 내에서 보안 URL을 동적으로 정의하려면 어떻게 해야 하는가?](#4446-어플리케이션-내에서-보안-url을-동적으로-정의하려면-어떻게-해야-하는가)
   - [44.4.7. LDAP에 대해 인증하면서 데이터베이스로부터 사용자 권한을 불러오려면 어떻게 해야 하는가?](#4447-ldap에-대해-인증하면서-데이터베이스로부터-사용자-권한을-불러오려면-어떻게-해야-하는가)
   - [44.4.8. 네임스페이스에 의해 생성된 bean의 속성을 변경하고자 한다. 하지만 이것을 지원하는 스키마가 없다. 네임스페이스 사용을 포기하지 않고 할 수 있는 방법은 무엇인가?](#4448-네임스페이스에-의해-생성된-bean의-속성을-변경하고자-한다-하지만-이것을-지원하는-스키마가-없다-네임스페이스-사용을-포기하지-않고-할-수-있는-방법은-무엇인가)

#### [45. 3.x에서 4.x로 마이그레이션(Migration)](#45-3x에서-4x로-마이그레이션migration-1)



<br/><br/><br/><br/>

----
Spring Security는 강력하며 높은 수준의 사용자정의가 가능한 인증 및 접근 제어 프레임워크이다. 이는 사실상 Spring 기반의 어플리케이션의 보안을 위한 표준이라고 할 수 있다.

# [1] 서문
Spring Security는 Java EE기반 엔터프라이즈 소프트웨어 애플리케이션을 위한 포괄적인 보안 솔루션을 제공한다. 본 참조 가이드를 통해 모험하면서 알게 되겠지만, 우리는 유용하고 높은 수준의 설정이 가능한 보안 시스템을 제공하고자 노력해왔다.

보안은 끊임없이 변화하는 목표이며 포괄적인 시스템 차원의 접근 방식을 추구하는 것이 중요하다. 보안 서클에서 우리는 "보안 계층"을 사용하도록 독려하며, 추가적인 보안이 제공되는 연속 계층을 통해 각 계층이 자체 권한 내에서 가능한 안전하게 보호되도록 하고 있다. 각 계층의 보안이 엄격해 질수록 어플리케이션은 더 강력하고 안전해질 것이다. 최하위 계층에서는 중간자 공격(man-in-the-middle attack)을 방지하기 위해 통신 보안, 시스템 식별과 같은 문제를 처리해야 할 것이다. 그 다음에는 승인된 시스템만이 연결을 시도할 수 있도록 하기 위해 일반적으로 VPN 또는 IP보안과 함께 방화벽을 사용할 것이다. 기업 환경에서는 백엔드 데이터베이스와 어플리케이션 서버로부터 공용서버를 분리하기 위해 DMZ를 만들 수도 있다. 운영체제 또한 권한이 없는 사용자의 프로세스 실행, 파일 시스템 보안강화와 같은 문제들을 해결하는 중요한 역할을 할 것이다. 더불어 보통 운영체제는 자체 방화벽이 설정되어 있다. 시스템에 대한 DOS(denial of service) 공격, 무차별 대입(brute force) 공격을 방어하고자 하는 경우도 있을 것이다. 그런 면에서, 침입 탐지 시스템은 각 시스템이 실시간으로 침입한 TCP/IP 주소를 차단하는 것과 같은 보호 조치를 취할 수 있도록 모니터링하고 공격에 대응하는데 특히 유용할 것이다. 상위 계층에서는 JVM(Java Virtual Machine)이 다른 Java type에 부여된 권한을 최소화하도록 설정되며, 어플리케이션은 그 고유의 문제영역에 관련된 특수 보안 설정(problem domain-specific security configuration)이 추가될 것이다. Spring Security는 이 설정을 보다 쉽게 할 수 있도록 도와준다.

물론 전 계층을 포괄하는 관리 요소들과 함께 위에서 언급한 모든 보안 계층을 적절하게 처리해야 한다. 전 계층을 관리하는 관리요소에는 보안 게시판 모니터링, 패치 적용, 직원 검사, 감사, 변경 관리, 엔지니어링 관리 시스템, 데이터 백업, 재해 복구, 성능 벤치마킹, 부하 모니터링, 중앙 집중식 로깅, 사고 대응 절차 등이 포함된다.

Spring Security는 엔터프라이즈 애플리케이션 보안 계층 지원에 주력하고 있으며, 당신은 보안 관련 문제에 있어 비즈니스 문제 영역(business problem domain)만큼이나 다양한 요구사항이 있다는 것을 알게 될 것이다. 은행업무 어플리케이션은 전자상거래 어플리케이션과 다른 요구사항을 가진다. 전자전자 상거래 어플리케이션은 기업의 판매 자동화 시스템과는 다른 요구사항을 가진다. 이러한 맞춤형 요구사항들은 어플리케이션 보안을 흥미롭고 도전적이며 의미있는 과제로 만든다.

먼저 [1. 시작하기](#1-시작하기-1) 전체 내용을 숙지하는 것을 추천한다. '시작하기'는 프레임워크에 대해 소개하며, 매우 빠른 실행을 도와주는 네임스페이스 기반 설정 시스템에 대해서 설명한다. Spring Security의 작동 방식과 몇 가지 필요한 클래스들에 대해서 이해하려면 [[2] 아키텍처(Architecture)와 구현(Implementation)](#2-아키텍처architecture와-구현implementation-1)을 보아야 한다. 이 가이드의 나머지 부분은 필요에 따라 읽을 수 있도록 좀 더 전통적인 참조문서 스타일로 구성되어 있다. 더불어 일반적인 어플리케이션 보안 이슈에 대해 가능한 많이 읽는 것을 추천한다. Spring Security는 모든 문제를 해결해주는 만병통치약이 아니다. 어플리케이션은 처음부터 보안을 고려하여 설계하는 것이 중요하다. 중간에 어플리케이션을 개조하려고 시도하는 것은 좋은 생각이 아니다. 특히 웹 어플리케이션을 구축하는 경우 처음부터 고려해야 하는 크로스 사이트 스크립팅(cross-site scripting), 요청 위조(request-forgery), 세션 하이재킹(session-hijacking)과 같은 많은 잠재적 취약점에 대해서 인지하고 있어야 한다. OWASP 웹 사이트 ([http://www.owasp.org](http://www.owasp.org))는 참고할 만한 많은 유용한 정보뿐만 아니라 웹 어플리케이션 취약점 상위 10개 목록을 관리한다.

본 참조 가이드가 유용하게 활용되기를 바라며, 당신의 피드백과 [제안](#81-이슈-트래킹)을 환영한다.

마지막으로 스프링 보안 [커뮤니티](#8-spring-security-커뮤니티-1)에 온 것을 환영한다.

<br/><br/><br/><br/>

## 1. 시작하기
본 가이드의 후반부에서는 많은 커스터마이징이 필요한 경우 이해하여야 하는 프레임워크 아키텍처와 구현 클래스들에 대한 심층적 논의를 제공한다. 이 장에서는 Spring Security 4.0을 소개하며, 프로젝트 연혁에 대한 간략한 개요와 프레임워크를 처음 사용하기 위한 방법을 살펴볼 것이다. 특히 모든 구현 클래스들을 개별적으로 연결해야 했던 전통적인 Spring bean 접근방식과 비교하여 훨씬 더 간단하게 어플리케이션을 보호하는 방법을 제공하는 네임스페이스 설정을 살펴볼 것이다.

또한 사용가능한 샘플 어플리케이션도 함께 살펴볼 것이다. 후반부 장을 보기 전에 이 샘플들을 먼저 실행해보고 경험하는 것을 추천한다.(프레임워크에 대한 이해도가 점점 높아지면 샘플들을 참고만 하여도 될 수도 있다.) 또한 프로젝트 구축과 그와 관련된 기사/비디오/교육자료 링크에 대한 유용한 정보가 있는 [프로젝트 웹사이트](https://projects.spring.io/spring-security/)를 checkout하기를 바란다.

<br/><br/><br/><br/>

## 2. 소개

### 2.1. Spring Security란?
Spring Security는 Java EE 기반 엔터프라이즈 소프트웨어 어플리케이션에 대한 전반적인 보안 서비스를 제공한다. 엔터프라이즈 소프트웨어 개발을 위한 선도적인 Java EE 솔루션인 Spring 프레임워크를 사용하여 구축된 프로젝트를 지원하는데 중점을 두고 있다. 엔터프라이즈 어플리케이션 개발을 위해 Spring을 사용하지 않는다면 Spring을 더 자세히 살펴볼 것을 권유한다. Spring에서 경험할 수 있는 친숙한 부분, 특히 의존성 주입 원칙은 Spring Security를 보다 쉽게 익히는데 도움이 될 것이다.

사람들은 Spring Security를 여러가지 이유로 사용하지만 대부분은 Java EE의 Servlet 상세 또는 EJB 상세의 보안기능이 전형적인 엔터프라이즈 어플리케이션 시나리오가 필요로 하는 깊이에 있어서 부족하다는 것을 알고 난 후에 Spring Security를 프로젝트에 적용하기 시작한다. 여기에서 앞서 말한 상세들은 WAR 또는 EAR 상태에서 적용할 수 없다는 것을 인지하는 것이 중요하다. 그러므로 만약 서버 환경을 변경한다면, 새로운 환경에서 어플리케이션 보안을 재구성해야 하고 이것은 많은 작업을 요하게 된다. Spring Security를 사용하면 이러한 문제들을 극복할 수 있으며, 수십개의 다른 유용하고 커스터마이징 가능한 보안 기능들을 사용할 수 있다.

어플리케이션 보안의 2가지 주요 영역은 "인증(Authentication)"과 "권한(Authorization)" (또는 "접근제어(Access-control)")이다. 이 2가지는 Spring Security가 목표로 하는 주요 영역이다. "인증(Authentication)"은 한 주체의 주체성을 확실히 하는 프로세스이다. (일반적으로 '주체'는 어플리케이션에서 작업을 수행할 수 있는 사용자, 기기 또는 어떠한 시스템을 의미한다.) "권한(authorization)"은 어플리케이션에서 한 주체가 작업을 수행하는 것을 허용할지 결정하는 프로세스이다. 권한을 결정이 필요한 시점이 도달하면, 주체의 신원은 이미 인증 프로세스에 의해 입증된 상태이다. 이러한 개념은 일반적이며, Spring Security에만 국한되는 개념이 아니다.

인증 단계에서 Spring Security는 광범위한 인증 모델을 지원한다. 이러한 인증 모델의 대부분은 제 3자(third-party)에 의해서 제공되거나 인터넷 엔지니어링 태스크 포스(Internet Engineering Task Force) 관련 표준 기관에 의해서 개발된다. 그에 더해 Spring Security는 자체적인 인증 기능들을 제공하기도 한다. 특히, Spring Security는 현재 아래와 같은 기술들과의 인증 통합을 지원한다.

- HTTP BASIC authentication headers (an IETF RFC-based standard)
- HTTP Digest authentication headers (an IETF RFC-based standard)
- HTTP X.509 client certificate exchange (an IETF RFC-based standard)
- LDAP (a very common approach to cross-platform authentication needs, especially in large environments)
- Form-based authentication (for simple user interface needs)
- OpenID authentication
- Authentication based on pre-established request headers (such as Computer Associates Siteminder)
- Jasig Central Authentication Service (otherwise known as CAS, which is a popular open source single sign-on system)
- Transparent authentication context propagation for Remote Method Invocation (RMI) and HttpInvoker (a Spring remoting protocol)
- Automatic "remember-me" authentication (so you can tick a box to avoid re-authentication for a predetermined period of time)
- Anonymous authentication (allowing every unauthenticated call to automatically assume a particular security identity)
- Run-as authentication (which is useful if one call should proceed with a different security identity)
- Java Authentication and Authorization Service (JAAS)
- Java EE container authentication (so you can still use Container Managed Authentication if desired)
- Kerberos
- Java Open Source Single Sign-On (JOSSO) *
- OpenNMS Network Management Platform *
- AppFuse *
- AndroMDA *
- Mule ESB *
- Direct Web Request (DWR) *
- Grails *
- Tapestry *
- JTrac *
- Jasypt *
- Roller *
- Elastic Path *
- Atlassian Crowd *
- 당신의 자체적인 인증 시스템 (아래 참조)

( * - 제 3자(third-party)에 의해서 제공되는 기술을 표시

많은 독립적인 소프트웨어 벤더들(ISVs)은 유연한 인증 모델의 선택이 중요하기 때문에 Spring Security를 채택한다. 이는 많은 작업을 수행하거나 고객에게 환경을 바꿀 것을 요구하지 않고 고객이 필요로 하는 것과 솔루션을 신속하게 통합할 수 있도록 한다. 위의 인증 메커니즘 중에서 어떠한 것도 사용자 요구에 맞지 않는 경우, 오픈 플렛폼인 Spring Security를 사용하여 간단하게 자체적인 인증 메커니즘으르 작성하면 된다. Spring Security의 많은 기업 고객들은 특정 보안 표준을 따르지 않는 레거시 시스템들과의 통합을 필요로 하며, Spring Security가 이러한 필요성 있는 시스템으로 여겨져 매우 뿌듯하다.

인증 메커니즘에 관계없이 Spring Security는 일련의 심층적인 권한 부여 기능들을 제공한다. 주요 3가지 관심 영역이 있는데 웹 요청 권한 부여, 메소드 호출 가능 권한 부여, 개별 도메인 객체 인스턴스에 대한 접근 권한 부여 이렇게가 이에 해당한다. 차이점을 이해하고자 한다면 Servlet 상세의 웹 패턴 보안 또는 EJB 컨테이너 관리 보안, 파일 시스템 보안에서의 권한 부여 기능들을 각각 한번 살펴보는 것이 좋다. Sprign Security는 이러한 모든 중요한 영역에서 깊이 있는 기능들을 제공한다. 이에 대해서는 본 참조 가이드의 뒷부분에서 설명할 것이다.

<br/><br/><br/>

### 2.2. 연혁
Spring Security는 2003년 말쯤에 "Spring을 위한 Acegi Security System"이란 이름으로 시작하였다. Spring 개발자들의 메일로 Spring 기반의 Security 구현에 대해 고려가 되었는지를 묻는 질문이 제기된 것이다. 당시 Spring 커뮤니티는 상대적으로 소규모였으며(특히 지금의 규모와 비교하면!), 실제로 Spring은 2003년초부터 SourceForge 프로젝트로만 제공되고 있었다. 그 질문에 대한 답변은 여러가지 모험을 하고 발전을 도모하기에도 부족한 시간이지만 그러한 부분은 가치있는 영역이라는 것이었다.

이러한 점들을 보면 간단한 보안 구현은 구축되었지만 배포되지 않았던 것이다. 몇주 후 Spring 커뮤니티의 또 다른 멤버가 보안에 대해 질의하였고 SourceForge의 코드가 제공되었다. 몇 가지 요청이 더 이어졌고 2004년 1월까지 약 20명이 코드를 사용하였다. 이러한 선구자들은 SourceForge 프로젝트를 제대로 진행해보자고 제안하는 다른 사람들과 함께하게 되었고 이 프로젝트는 2004년 3월에 정식 발표되었다.

초기에 프로젝트는 자체적인 인증 모듈이 없었다. 보안 관리 컨테이너(Container Managed Security)는 권한에 중점을 두기 보다 Acegi Security를 이용한 인증 프로세스를 더 중요시하였다. 이는 처음에는 적합하였지만 점점 더 많은 사용자들이 추가적인 컨테이너 지원을 요구함에 따라 컨테이너별 인증 인터페이스의 근본적인 한계점이 명확히 드러나게 되었다. 또한 컨테이너 클래스패스에 새로운 JAR 파일을 추가하는 것에 관련하여 문제가 있었다. 이는 최종사용자의 혼란과 잘못된 구성의 공통적인 원인이었다.

이후 Acegi 보안관련 인증 서비스가 도입되었다. 약 1년 후, Acegi Security는 공식적인 Spring 프레임워크 서브 프로젝트가 되었다. 2년 반 이상의 수많은 생산 소프트웨어 프로젝트의 활발한 사용, 수 백개의 구현체와 커뮤니티 기여가 있고 난 이후, 1.0.0 최종 배포버전은 2006년 5월에 발표되었다.

Acegi Security는 2007년 말쯤 공식적인 Spring 포트폴리오 프로젝트가 되었고 "Spring Security"로 명칭이 변경되었다.

오늘날 Sprign Security는 강력하고 활발한 오픈 소스 커뮤니티를 가지고 있다. 포럼에서는 Spring Security에 대한 수 천개의 메시지가 있기도 하다. 또한 코드를 활용하여 일하거나 정기적으로 패치내역을 공유하고 개발자들을 지원하는 활발한 커뮤니티 활동을 하는 핵심 개발자들이 있다.

<br/><br/><br/>

### 2.3. 배포버전(Realease Numbering)
Spring Security 배포버전 번호를 매기는 방식을 이해하는 것은 유용하다. 이는 프로젝트의 상위 배포버전으로의 마이그레이션을 하게 되었을 때 필요한 노력(또는 부족함)을 파악하는데 도움이 된다. 통상 배포버전은 세 쌍의 정수를 사용한다(MAJOR, MINOR, PATCH). MAJOR 버전은 호환되지 않는 큰 규모의 API 업그레이드를 의미한다. MINOR 버전은 이전 minor 버전들과 소스 또는 바이너리 호환성을 잘 유지하며 업그레이드 하는 것을 의미한다. 일부 설계 변경 또는 비호환 업데이트가 있을 수도 있다. PATCH 버전은  버그 및 결함을 수정하는 변경을 제외하고 전후방 완벽하게 호환 가능한 업그레이드를 하는 것을 의미한다.

변경에 영향을 받는 범위는 코드가 얼마나 잘 통합되어 있는지에 따라 달라진다. 커스터마이징을 많이한 경우에 간단한 네임스페이스 설정을 사용한 경우보다 영향을 많이 받을 가능성이 크다.

새 버전을 배포하기 전에는 항상 어플리케이션을 철저히 테스트해야 한다.

<br/><br/><br/>

### 2.4. Spring Security 시작하기
Spring Security은 여러가지 방법으로 적용할 수 있다. Spring Security 메인 페이지에서 패키지를 다운로드하거나 Maven Central repository(또는 스냅샷 및 마일스톤<sup id="footkey1">[1#](#footnote1)</sup> 배포를 위한 Spring Maven repository)에서 개별 jar 파일들을 다운로드 할 수 있다. 아니면 직접 소스에서 프로젝트를 빌드할 수도 있다.

__<sub id="footnote1">1#</sub>__ <sub>마일스톤(Milestone)은 프로젝트 진행 과정에서 어떤 중요한 시점을 의미한다. 따라서 마일스톤 배포라고 하면 정식 배포 버전은 아니지만 어떠한 중요한 업그레이드를 위한 배포라고 생각하면 될 듯 하다. -옮긴이 ([읽던 곳으로 돌아가기](#footkey1))</sub>

<br/>

### 2.4.1. Maven으로 시작하기
최소한의 Spring Security Maven 의존성은 일반적으로 아래와 같다.

__pom.xml__
```xml
<dependencies>
  <!-- ... 그 외 의존성 요소들 ... -->
  <dependency>
  	<groupId>org.springframework.security</groupId>
  	<artifactId>spring-security-web</artifactId>
  	<version>4.2.3.RELEASE</version>
  </dependency>
  <dependency>
  	<groupId>org.springframework.security</groupId>
  	<artifactId>spring-security-config</artifactId>
  	<version>4.2.3.RELEASE</version>
  </dependency>
</d1ependencies>
```

LDAP, OpenID 등 추가적인 기능을 사용하는 경우 [2.4.3. 프로젝트 모듈](#243-프로젝트-모듈)을 참고해야 한다.

### Maven Repositories
모든 GA 배포버전('.RELEASE'로 끝나는 버전)은 Maven Central에 배포되므로 pom.xml에 추가적인 Maven repository들을 선언할 필요가 없다.

스냅샷 버전을 사용하는 경우에는 아래와 같이 Spring Snapshot repository를 선언해야 한다.

__pom.xml__
```xml
<repositories>
  <!-- ... 그 외 repository 요소들 ... -->
  <repository>
  	<id>spring-snapshot</id>
  	<name>Spring Snapshot Repository</name>
  	<url>http://repo.spring.io/snapshot</url>
  </repository>
</repositories>
```

마일스톤 버전 또는 배포 예비 버전을 사용하고자 한다면 아래와 같이 Spring Milstone repository를 선언해야 한다.

__pom.xml__
```xml
<repositories>
  <!-- ... 그 외 repository 요소들 ... -->
  <repository>
  	<id>spring-milestone</id>
  	<name>Spring Milestone Repository</name>
  	<url>http://repo.spring.io/milestone</url>
  </repository>
</repositories>
```

### Spring Framework Bom
Spring Security는 Spring 프레임워크 4.3.9.RELEASE를 사용하여 빌드하도록 만들어졌지만 Spring 4.0.x 버전들과 함께 작동되어야 한다. 여기서 많은 사용자들이 직면하는 문제는 Spring Security의 이행적(transitive) 의존성<sup id="footkey2">[#2](#footnote2)</sup>이 빌드 중 일부에서 Spring 프레임워크 4.3.9.RELEASE를 사용하지 않게 만들기도 한다는 것이다. <sub>(글의 흐름상 의역하였으나, 내가 이해하고 있는 부분이 맞는지 확인해주실 분이 계시면 확인을 부탁드린다.-옮긴이)</sub> 이는 classpath 이상현상을 야기할 수 있다. 이 문제를 회피하는 한 가지 방법은 모든 Spring 프레임워크 모듈을 pom.xml의 ```<dependencyManagement>``` 요소 하위에 포함하는 것이다. 다른 방법으로는 아래와 같이 pom.xml의 ```<dependencyManagement>``` 요소 하위에 ```spring-framework-bom```<sup id="footkey3">[#3](#footnote3)</sup>을 포함하는 것이다.

__pom.xml__
```xml
<dependencyManagement>
	<dependencies>
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-framework-bom</artifactId>
  		<version>4.3.9.RELEASE</version>
  		<type>pom</type>
  		<scope>import</scope>
  	</dependency>
	</dependencies>
</dependencyManagement>
```

이렇게 설정하면 Spring Security의 모든 이행적 의존성이 Spring 4.3.9.RELEASE 모듈을 사용하도록 할 수 있다.

> 이 방식은 Maven의 "BOM(bill of materials)" 개념을 사용하고 있으며, Maven 2.0.9 이상에서만 사용할 수 있다. 의존성이 어떻게 해결되는지에 대한 더 자세한 정보는 [Maven의 Dependency Mechanism 소개 문서](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)를 참고하면 된다.

__<sub id="footnote2">#2</sub>__ <sub>이행적 의존성(transitive dependencies)이란, 한 가지 의존성에 대해 2가지 이상의 버전을 포함하고 있을 경우, 충돌이 발생하면 특정 기준에 따라 이행(전이)할 의존성이 선택되는 것을 말한다.(http://www.baeldung.com/spring-maven-bom 참고) -옮긴이 ([읽던 곳으로 돌아가기](#footkey2))</sub>

__<sub id="footnote3">#3</sub>__ <sub>Spring Framework BOM이란, 이행적 의존성에 의해 발생할 수 있는 이상현상들을 방지하기 위해 의존성을 관리해주는 Spring Project이다. bom 파일에 의존성 관계들이 명시되어 있으며 모든 빌드는 이 bom파일에 명시된 의존성에 따르도록 하여 경우에 따라 의존성이 이행(전이)되는 것을 막을 수 있다. (http://www.baeldung.com/spring-maven-bom 참고) -옮긴이 ([읽던 곳으로 돌아가기](#footkey3))</sub>

<br/>

### 2.4.2. Gradle로 시작하기
최소한의 Spring Security Gradle 의존성은 일반적으로 아래와 같다.

__build.gradle__
```gradle
dependencies {
	compile 'org.springframework.security:spring-security-web:4.2.3.RELEASE'
	compile 'org.springframework.security:spring-security-config:4.2.3.RELEASE'
}
```

LDAP, OpenID 등 추가적인 기능을 사용하는 경우 [2.4.3. 프로젝트 모듈](#243-프로젝트-모듈)을 참고해야 한다.

### Gradle Repositories
모든 GA 배포버전('.RELEASE'로 끝나는 버전)은 Maven Central에 배포되므로 mavenCentral() repository만 사용해도 충분하다.

__build.gradle__
```gradle
repositories {
	mavenCentral()
}
```

스냅샷 버전을 사용하는 경우에는 아래와 같이 Spring Snapshot repository를 선언해야 한다.

__build.gradle__
```gradle
repositories {
	maven { url 'https://repo.spring.io/snapshot' }
}
```

마일스톤 버전 또는 배포 예비 버전을 사용하고자 한다면 아래와 같이 Spring Milstone repository를 선언해야 한다.

__build.gradle__
```gradle
repositories {
	maven { url 'https://repo.spring.io/milestone' }
}
```

### Spring 4.0.x와 Gradle 사용하기
기본적으로 Gradle은 한 가지 의존성에 대해 2가지 이상의 버전을 포함하고 있을 경우, 가장 최신 버전의 의존성을 사용한다. 이것은 Spring Security 4.2.3.RELEASE를 Spring 프레임워크 4.3.9.RELEASE와 함께 사용할 때 종종 추가작업이 필요없다는 것이다. 그러나 때로는 문제가 발생할 수 있으므로 아래와 같이 [Gradle의 ResolutionStrategy](http://www.gradle.org/docs/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html)를 사용하여 문제를 완화하는 것이 좋다.

__build.gradle__
```gradle
configurations.all {
	resolutionStrategy.eachDependency { DependencyResolveDetails details ->
		if (details.requested.group == 'org.springframework') {
			details.useVersion '4.3.9.RELEASE'
		}
	}
}
```

이렇게 설정하면 Spring Security의 모든 이행적 의존성이 Spring 4.3.9.RELEASE 모듈을 사용하도록 할 수 있다.

> 이 예제는 Gradle 1.9를 사용하지만 Gradle의 향후 버전에서는 수정이 필요할 수 있다.

<br/>

### 2.4.3. 프로젝트 모듈
Spring Security 3.0은 서로 다른 기능 영역들 또는 third-party 의존성을 명확히 구분하는 분리된 jar 파일로 세분화 된다. Maven을 사용하여 프로젝트를 빌드하는 경우, 이러한 jar파일들은 ```pom.xml```에 추가하여야 하는 모듈이다. Maven을 사용하지 않더라도 ```pom.xml``` 파일을 참조하여 third-party 의존성 및 버전에 대한 아이디어를 얻는 것을 추천하다. 또는 샘플 어플리케이션에 포함된 라이브러리를 확인해보는 것도 좋다.

### Core - spring-security-core.jar
핵심 인증과 접근 제어에 대한 클래스 및 인터페이스, 원격지원, 기본 프로비저닝(provisioning)<sup id="footkey4">[#4](#footnote4)</sup> API들을 포함한다.
- ```org.springframework.security.core```
- ```org.springframework.security.access```
- ```org.springframework.security.authentication```
- ```org.springframework.security.provisioning```

__<sub id="footnote4">#4</sub>__ <sub>프로비저닝(provisioning)이란, 자원을 사용자 또는 비즈니스 요구사항에 맞에 할당, 배치, 배포해서 신속하게 사용할 수 있도록 미리 만들어 놓는 것을 의미한다. -옮긴이 ([읽던 곳으로 돌아가기](#footkey4))</sub>

### Remoting - spring-security-remoting.jar
Sprign Remoting과의 통합을 지원한다. Spring Remoting을 사용하여 원격 클라이언트를 작성하지 않는 경우 이 모듈은 필요하지 않다. 메인 패키지는 ```org.springframework.security.remoting```이다.

### Web - spring-security-web.jar
필터와 웹 보안과 관련된 인프라 코드, 또는 서블릿 API 의존성에 대한 모든 것을 포함한다. Spring Security 웹 인증 서비스 또는 URL 기반 접근 제어가 필요한 경우 이 모듈이 필요할 것이다. 메인 패키지는 ```org.springframework.security.web```이다.

### Config - spring-security-config.jar
security에 대한 네임스페이스 구문분석 코드와 Java 설정 코드를 포함한다. 설정을 위한 Spring Security XML 네임스페이스 또는 Spring Security의 Java 설정을 사용한다면 이 모듈이 필요하다. 메인 패키지는 ```org.springframework.security.config```이다. 어떠한 클래스들도 직접적으로 어플리케이션에서 사용하지 않는다.

### LDAP - spring-security-ldap.jar
LDAP 인증과 프로비저닝(provisioning) 코드이다. LDAP인증을 사용하거나 LDAP 사용자 진입을 관리해야하는 경우 필요하다. 최상위 패키지는 ```org.springframework.security.ldap```이다.

### ACL - spring-security-acl.jar
특수 도메인 객체에 대한 ACL 구현체이다. 어플리케이션 내 특정한 도메인 객체 인스턴스에 보안을 적용할 때 사용한다. 최상위 패키지는 ```org.springframework.security.acls```이다.

### CAS - spring-security-cas.jar
Spring Security의 CAS 클라이언트 통합을 지원한다. CAS single sign-on 서버와 함께 Spring Security 웹 인증을 사용하고자 할 경우 사용한다. 최상위 패키지는 ```org.springframework.security.cas```이다.

### OpenID - spring-security-openid.jar
OpenID 웹 인증을 지원한다. 외부 OpenID 서버에 대해 사용자를 인증하고자 할 경우 사용한다. ```org.springframework.security.openid```. 이를 사용하려면 OpenID4Java가 필요하다.

### Test - spring-security-test.jar
Spring Security를 테스팅하는 것을 지원한다.

<br/>

### 2.4.4. 소스 Checkout 하기
Spring Security는 오픈 소스 프로젝트이기 때문에 git을 사용하여 소스코드를 체크아웃해 보기를 강력하게 추천한다. 체크아웃을 하면 모든 샘플 어플리케이션에 접근할 수 있으며 Spring Security 프로젝트의 최신 버전을 쉽게 빌드할 수 있다. 또한 프로젝트 소스를 가지고 있는 것은 디버깅에 큰 도움이 된다. 예외 stack trace는 더 이상 잘 알려지지 않은 문제가 아니다. 하지만 소스를 체크아웃 받아 사용하는 것은 이러한 문제가 발생하는 행으로 곧바로 이동하여 문제를 빠르게 해결할 수 있게 한다. 소스는 프로젝트에 대한 최고의 문서이며 이따금 무엇이 실제로 어떻게 작동하는지 알아낼 수 있는 가장 심플한 공간이라고 할 수 있다.

프로젝트 소스를 체크아웃하려면 아래와 같은 git 명령을 사용하여라.

```cmd
git clone https://github.com/spring-projects/spring-security.git
```

이렇게 입력하면 로컬 컴퓨터에서 프로젝트의 (모든 배포 버전과 브랜치를 포함한) 전체 과거내역에 접근할 수 있게 된다.

<br/><br/><br/><br/>

## 3. Spring Security 4.2의 새로운 점
무엇보다도 Spring Security 4.2는 Spring 프레임워크 5를 일찍이 지원하고 있다. 80개 이상의 이슈를 해결한 버전 4.2.0.M1, 4.2.0.RC1, 4.2.0.RELEASE에 대한 변경로그를 확인할 수 있을 것이다. 압도적으로 강력한 기능들은 대부분 커뮤니티에 의해서 제공되었다. 아래에서 이 배포버전의 주요 내용을 살펴볼 것이다.

<br/>

### 3.1. 웹 개선사항
- [#3812](https://github.com/spring-projects/spring-security/pull/3812) - [Jackson Support](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#jackson)
- [#4116](https://github.com/spring-projects/spring-security/pull/4116) - [Referrer Policy](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#headers-referrer)
- [#3938](https://github.com/spring-projects/spring-security/pull/3938) - Add [HTTP response splitting prevention](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#request-matching)
- [#3949](https://github.com/spring-projects/spring-security/issues/3949) - Add [bean reference support to @AuthenticationPrincipal.](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#mvc-authentication-principal)
- [#3978](https://github.com/spring-projects/spring-security/pull/3978) - Support for Standford WebAuth and Shibboleth using the newly added [RequestAttributeAuthenticationFilter](https://docs.spring.io/spring-security/site/docs/4.2.x-SNAPSHOT/apidocs/org/springframework/security/web/authentication/preauth/RequestAttributeAuthenticationFilter.html).
- [#4076](https://github.com/spring-projects/spring-security/issues/4076) - Document [Proxy Server](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#appendix-proxy-server) Configuration
- [#3795](https://github.com/spring-projects/spring-security/issues/3795) - ```ConcurrentSessionFilter``` supports ```InvalidSessionStrategy```
- [#3904](https://github.com/spring-projects/spring-security/pull/3904) - Add ```CompositeLogoutHandler```

<br/>

### 3.2. 설정 개선사항
- [#3956](https://github.com/spring-projects/spring-security/pull/3956) - Central configuration of the [default role prefix](https://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html#m3to4-role-prefixing). See the issue for details.
- [#4102](https://github.com/spring-projects/spring-security/issues/4102) - Custom default configuration in ```WebSecurityConfigurerAdapter```. See [Section 5.10, “DSL 커스터마이징하기”](#510-dsl-커스터마이징하기)
- [#3899](https://github.com/spring-projects/spring-security/issues/3899) - [concurrency-control@max-sessions](#max-sessions) supports unlimited sessions.
- [#4097](https://github.com/spring-projects/spring-security/issues/4097) - [intercept-url@request-matcher-ref](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#nsa-intercept-url-request-matcher-ref) adds more powerful request matching support to the XML namespace.
- [#3990](https://github.com/spring-projects/spring-security/issues/3990) - Support for constructing ```RoleHierarchy``` from ```Map``` (i.e. ```yml```)
- [#4062](https://github.com/spring-projects/spring-security/pull/4062) - Custom cookiePath to ```CookieCsrfTokenRepository```
- [#3794](https://github.com/spring-projects/spring-security/issues/3794) - Allow configuration of ```InvalidSessionStrategy``` on ```SessionManagementConfigurer```
- [#4020](https://github.com/spring-projects/spring-security/issues/4020) - Fix Exposing Beans for defaultMethodExpressionHandler can prevent Method Security

<br/>

### 3.3. 기타 새로운 점
- [#4080](https://github.com/spring-projects/spring-security/issues/4080) - Spring 5 support
- [#4095](https://github.com/spring-projects/spring-security/issues/4095) - Add ```UserBuilder```
- [#4018](https://github.com/spring-projects/spring-security/issues/4018) - Fix after ```csrf()``` is invoked, future ```MockMvc``` invocations use original ```CsrfTokenRepository```
- Version Updates

<br/><br/><br/><br/>

## 4. 샘플과 가이드
Spring Security를 시작하고자 한다면, 샘플 어플리케이션을 활용하는 것이 가장 좋다.

__Table 4.1. 샘플 어플리케이션(Sample Applications)__

| 샘플소스 | 설명 | 가이드 |
  |---|---|---|
  | [Hello Spring Security](https://github.com/spring-projects/spring-security/tree/4.2.3.RELEASE/samples/javaconfig/helloworld) | Java기반 설정을 사용하는 기 존재하는 어플리케이션에 Spring Security를 적용하는 방법을 설명한다. | [Hello Spring Security 가이드](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/guides/html5/helloworld-javaconfig.html) |
  | [Hello Spring Security Boot](https://github.com/spring-projects/spring-security/tree/4.2.3.RELEASE/samples/boot/helloworld) | Spring Boot 어플리케이션에 Spring Security를 적용하는 방법을 설명한다. | [Hello Spring Security Boot 가이드](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/guides/html5/helloworld-boot.html) |
  | [Hello Spring Security XML](https://github.com/spring-projects/spring-security/tree/4.2.3.RELEASE/samples/xml/helloworld) | XML기반 설정을 사용하는 기 존재하는 어플리케이션에 Spring Security를 적용하는 방법을 설명한다.  | [Hello Spring Security XML 가이드](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/guides/html5/helloworld-xml.html) |
  | [Hello Spring MVC Security](https://github.com/spring-projects/spring-security/tree/4.2.3.RELEASE/samples/javaconfig/hellomvc) | 기 존재하는 Spring MVC 어플리케이션에 Spring Security를 적용하는 방법을 설명한다. | [Hello Spring MVC Security 가이드](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/guides/html5/hellomvc-javaconfig.html) |
  | [Custom Login Form](https://github.com/spring-projects/spring-security/tree/4.2.3.RELEASE/samples/javaconfig/form) | 로그인 폼을 커스터마이징하여 만드는 방법을 설명한다. | [Custom Login Form 가이드](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/guides/html5/form-javaconfig.html) |

<br/><br/><br/><br/>

## 5. Java 설정
Spring Framework 3.1부터 [Java 기반 설정](https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java)이 지원되었다. Spring Security은 3.2부터 사용자가 XML을 사용하지 않고도 Spring Security를 쉽게 설정할 수 있는 Spring Security Java 설정이 지원되었다.
[6. Security 네임스페이스 설정](#6-security-네임스페이스-설정-1) 내용이 익숙하다면 그 내용과 Security Java 설정 지원과의 유사한 부분들을 발견할 수 있을 것이다.

> Spring Security는 Spring Security Java 설정 사용방법에 대한 [많은 샘플 어플리케이션](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig)을 제공하고 있다.

<br/>

### 5.1. 웹 Security Java 설정
첫 번째 단계는 Spring Security Java 설정을 생성하는 것이다. 설정은 어플리케이션 내 모든 보안(어플리케이션 URL 방어하기, 전송된 사용자 이름과 비밀번호 확인하기, 로그인 폼으로 리다이렉팅하기 등)을 담당하는 springSecurityFilterChain이라는 Servlet 필터를 생성한다. 아래 예제는 Spring Security Java 설정의 가장 기본적인 예제이다.

<a id="WebSecurityConfig"></a>
```java
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Bean
	public UserDetailsService userDetailsService() throws Exception {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withUsername("user").password("password").roles("USER").build());
		return manager;
	}
}
```

이 설정은 몇 줄 되지 않지만 많은 일을 한다. 아래 기능 요약을 확인하자.
- 어플리케이션의 모든 URL에 인증이 필요하게 한다.
- 로그인 폼을 생성해준다.
- 인증폼에서 사용자 이름이 'user'이고 비밀번호가 'password'인 사용자가 인증하는 것을 허용한다.
- 사용자가 로그아웃하는 것을 허용한다.
- [CSRF attack](https://en.wikipedia.org/wiki/Cross-site_request_forgery)<sup id="footkey5">[#5](#footnote5)</sup> 방어
- [세션 강제고정(Session Fixation)](https://en.wikipedia.org/wiki/Session_fixation)<sup id="footkey5">[#6](#footnote6)</sup> 방어
- Security 헤더 통합
   - 안전한 요청을 위한 [엄격한 HTTP 전송 Security(HTTP Strict Transport Security)](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security)
   - [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx) 통합
   - 캐시 제어 (정적 리소스를 캐싱하는 어플리케이션에 의해 추후 재정의될 수 있음)
   - [X-XSS-Protection](https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx) 통합
   - [Clickjacking](https://en.wikipedia.org/wiki/Clickjacking)을 막기 위해 X-Frame-Options 통합
- 아래와 같은 Servlet API 메서드와 통합한다.
   - [HttpServletRequest#getRemoteUser()](http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser())
   - [HttpServletRequest.html#getUserPrincipal()](http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal())
   - [HttpServletRequest.html#isUserInRole(java.lang.String)](http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String))
   - [HttpServletRequest.html#login(java.lang.String, java.lang.String)](http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String))
   - [HttpServletRequest.html#logout()](http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout())

__<sub id="footnote5">#5</sub>__ <sub>CSRF(Cross-site request forgery)란, 웹 어플리케이션이 신뢰하는 사용자로부터 권한이 부여되지 않은 명령을 전송하는 악성 공격 유형이다. 그러한 명령들을 전송하는 방법에는 여러가지가 있는데, 예를 들어 특수 제작된 이미지 태그, 숨겨진 양식 또는 JavaScript XMLHttpRequest 등이 그 방법이 될 수 있다. 이러한 것들은 사용자와의 상호작용을 통하지 않고 사용자 모르게 동작할 수 있다. (참고: https://en.wikipedia.org/wiki/Cross-site_request_forgery)-옮긴이 ([읽던 곳으로 돌아가기](#footkey5))</sub>

__<sub id="footnote6">#6</sub>__ <sub>세션 강제고정(Session Fixation)이란, 다른 사람의 세션 식별자를 고정(조회 또는 설정)할 수 있는 시스템의 취약점을 악용하려는 시도이다. 대부분의 세션 고정 공격은 웹 기반이며 URL(query string) 또는 POST data로부터 허용된 세션 식별자에 의존한다. (참고: https://en.wikipedia.org/wiki/Session_fixation)-옮긴이 ([읽던 곳으로 돌아가기](#footkey6))</sub>

<br/>

### 5.1.1. AbstractSecurityWebApplicationInitializer
다음 단계는 ```springSecurityFilterChain```을 war에 등록하는 것이다. 이는 Servlet 3.0+ 환경에서 [Spring의 WebApplicationInitializer를 지원](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config)하는 Java 설정으로 할 수 있다. Spring Security는 ```springSecurityFilterChain```이 등록되도록 해주는 기본 클래스인 ```AbstractSecurityWebApplicationInitializer```를 제공한다. ```AbstractSecurityWebApplicationInitializer```를 사용하는 방법은 Spring 사용여부 또는 Spring Security가 어플리케이션에서 유일한 Spring 구성요소 인지의 여부에 따라 달라진다.
- [5.1.2. AbstractSecurityWebApplicationInitializer (Spring을 사용하지 않는 경우)](#512-abstractsecuritywebapplicationinitializer-spring을-사용하지-않는-경우) - 이미 Spring을 사용하지 않는 경우에 사용
- [5.1.3. AbstractSecurityWebApplicationInitializer (Spring MVC와 함께 사용하는 경우)](#513-abstractsecuritywebapplicationinitializer-spring-mvc와-함께-사용하는-경우) - 이미 Spring을 사용하고 있는 경우에 사용

<br/>

### 5.1.2. AbstractSecurityWebApplicationInitializer (Spring을 사용하지 않는 경우)
Spring 또는 Spring MVC를 사용하지 않는 경우에는 부모 클래스('AbstractSecurityWebApplicationInitializer')에 ```WebSecurityConfig```를 전달하여 설정해야 한다. 아래 예제를 확인하자.

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}
```

```SecurityWebApplicationInitializer```는 아래와 같은 작업을 수행한다.
- 어플리케이션의 모든 URL에 대한 springSecurityFilterChain 필터를 자동으로 등록한다.
- [WebSecurityConfig](#WebSecurityConfig)를 로드하는 ContextLoaderListener를 추가한다.

<br/>

### 5.1.3. AbstractSecurityWebApplicationInitializer (Spring MVC와 함께 사용하는 경우)
어플리케이션 다른 부분에서 Spring을 사용한다면 아마도 Spring 설정을 로드해주는 WebApplicationInitializer를 이미 사용하고 있을 것이다. 이런 경우에는 [5.1.2](#512-abstractsecuritywebapplicationinitializer-spring을-사용하지-않는-경우)와 같이 설정을 사용하면 오류가 발생한다. 그래서 그렇게 설정하지 않고 기존 ApplicationContext에 Spring Security를 등록하는 방법을 사용해야 한다. 예를 들어 Spring MVC를 사용한다면 아래와 같이 SecurityWebApplicationInitializer를 작성하는 것이다.

```java
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}
```

이렇게 하면 어플리케이션의 모든 URL에 대한 springSecurityFilterChain 필터가 등록된다. 그런 다음 기존 ApplicationInitializer에 ```WebSecurityConfig```가 제대로 로드되었는지 확인하면 된다. 예를 들어 Spring MVC를 사용한다면 ```getRootConfigClasses()```를 활용해보자.

```java
public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... 그 외 overrides ...
}
```

<br/><br/><br/>

### 5.2. HttpSecurity
여기까지 [WebSecurityConfig](#WebSecurityConfig)는 사용자를 인증하는 방법에 대한 정보만 포함하고 있다. 모든 사용자에게 인증을 요구해야 한다는 것과 폼 기반 인증을 지원해야 한다는 것에 대한 정보는 없는 셈이다. Spring Security는 이러한 것들을 어떻게 알고 설정해주는 걸까? 어떻게 아냐면 WebSecurityConfig의 부모클래스인 ```WebSecurityConfigurerAdapter```가 다음과 같은 ```Configure(HttpSecurity http)``` 메서드에서 기본적인 설정을 제공하기 때문이다.

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.and()
		.httpBasic();
}
```

위와 같은 기본 설정은 다음과 같은 내용을 설정한다.
- 어플리케이션에 대한 어떤 요청이든 사용자에게 인증을 요구하도록 한다.
- 사용자가 폼 기반 로그인을 사용하여 인증할 수 있도록 한다.
- 사용자가 HTTP 기본 인증을 사용하여 인증할 수 있도록 한다.

이 설정은 XML 네임스페이스 설정과 매우 흡사하다.

```xml
<http>
	<intercept-url pattern="/**" access="authenticated"/>
	<form-login />
	<http-basic />
</http>
```

Java 설정에서 XML에서의 닫는 태그와 동일한 표현은 ```and()``` 메서드 이다. 이 메서드는 설정을 계속 연결지어 할 수 있도록 해주는 역할을 한다. 또한 위의 코드를 읽어보면 Java설정과 동일하게 '승인된 요청, 폼 로그인, HTTP 기본 인증'을 설정하고자 함을 알 수 있다.

그러나 Java 설정은 기본 URL과 파라미터가 조금 다르다. 사용자 정의 로그인 페이지를 생성할 때 이러한 부분을 잘 알고 있어야 한다. 그래야 URL을 더 RESTful하게 만들 수 있다. 추가적으로, 우리가 [정보 유출](https://www.owasp.org/index.php/Information_Leak_(information_disclosure))을 방지해주는 Spring Security를 사용한다고 확신할 수 없다. 예를 들어.. <sub>(작성자가 작성하다 만 것인지는 모르겠지만.. 여기에서 내용이 끝난다. 왜 확신할 수 없는지에 대한 예가 나와야 하는데 내용이 끝났다;; 혹시 내가 잘못 생각하였다면 댓글 또는 github에서 pr을 부탁드린다.-옮긴이)</sub>

<br/><br/><br/>

### 5.3. Java 설정과 Form 로그인
HTML파일 또는 JSP에 대한 언급이 없으므로 로그인을 시도할 때 로그인 폼이 어디로부터 오는지 궁금할 것이다. Spring Security의 기본 설정에서 로그인 페이지의 URL을 명시적으로 설정하지 않기 때문에 Spring Security는 사용하도록 설정된 기능 기반으로 로그인을 처리하는 URL의 표준 값을 사용하여 사용자가 로그인 후 이동할 기본 타켓 URL을 자동으로 생성한다.

자동으로 생성된 로그인 페이지가 빠르게 시작하기에 편리하지만 대부분의 어플리케이션은 자체적인 로그인 페이지를 제공하기를 원한다. 그래서 그렇게 하기를 원한다면 아래와 같이 설정을 수정하면 된다.

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.loginPage("/login") //1
			.permitAll();        //2
}
```
- (1) 수정된 설정은 로그인 페이지 경로를 구체적으로 명시한다.
- (2) 모든 사용자(즉, 인증되지 않은 사용자)에게 로그인 페이지에 대한 접근 권한을 부여해야 한다. formLogin().permitAll() 메서드는 모든 사용자에게 폼 기반 로그인과 관련된 모든 URL에 대한 접근 권한을 부여한다.

설정을 위해 구현한 로그인 페이지 예제는 아래와 같다.

> 아래 로그인 페이지는 현재 설정하고자 하는 것을 잘 보여준다. 일부 기본값이 기대에 못 미친다면 쉽게 설정을 변경할 수 있다.

```html
<c:url value="/login" var="loginUrl"/>
<form action="${loginUrl}" method="post">       <!--1-->
	<c:if test="${param.error != null}">        <!--2-->
		<p>
			Invalid username and password. (사용자 이름과 비밀번호를 찾을 수 없습니다.)
		</p>
	</c:if>
	<c:if test="${param.logout != null}">       <!--3-->
		<p>
			You have been logged out. (로그아웃 되었습니다.)
		</p>
	</c:if>
	<p>
		<label for="username">Username</label>
		<input type="text" id="username" name="username"/>	<!--4-->
	</p>
	<p>
		<label for="password">Password</label>
		<input type="password" id="password" name="password"/>	<!--5-->
	</p>
	<input type="hidden"
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/>          <!--6-->
	<button type="submit" class="btn">Log in</button>
</form>
```

- (1) /login URL에 대한 POST는 사용자 인증을 시도한다.
- (2) query 파라미터에 오류가 있으면 인증은 실패한다.
- (3) query 파라미터에 로그아웃 값이 있으면 사용자는 성공적으로 로그아웃이 된 것이다.
- (4) 사용자 이름은 username이라는 HTTP 파라미터로 전송되어야 한다.
- (5) 비밀번호는 password라는 HTTP 파라미터로 전송되어야 한다.
- (6) [18.4.3. CSRF 토큰 포함하기](#1843-csrf-토큰-포함하기) 절 참고. 더 자세한 내용은 [18. 사이트간 요청 위조(Cross Site Request Forgery, CSRF)](#18-사이트간-요청-위조cross-site-request-forgery-csrf-1)을 참고하면 된다.

<br/><br/><br/>

### 5.4. 권한 부여 요청 (Authorize Requests)
위에 예제들은 어플리케이션의 모든 URL에 대해 인증된 사용자만 허용하는 방식이다. 하지만 ```http.authorizeRequests()``` 메소드에 여러가지 설정을 추가해서 사용자와 URL에 대해 구체적으로 정의할 수 있다. 아래 예제를 보자.

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()                                                              //1
			.antMatchers("/resources/**", "/signup", "/about").permitAll()                  //2
			.antMatchers("/admin/**").hasRole("ADMIN")                                      //3
			.antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")            //4
			.anyRequest().authenticated()                                                   //5
			.and()
		// ...
		.formLogin();
}
```

- (1) ```http.authorizeRequests()``` 메서드의 하위 설정인 matcher는 선언된 순서대로 고려된다.
- (2) 어떤 사용자든 접근할 수 있는 URL 패턴을 여러개 설정하였다. 구체적으로 설정을 설명하자면, URL이 "/resources/"로 시작하거나 "/signup" 또는 "/about"이라면 어떤 사용자이든 접근할 수 있다.
- (3) "/admin/"으로 시작하는 URL은 "ROLE_ADMIN" 권한을 가진 사용자만 접근할 수 있다. hasRole 메서드를 사용하면 "ROLE_" 접두어를 사용하지 않아도 된다.
- (4) "/db/"로 시작하는 URL은 "ROLE_ADMIN", "ROLE_DBA" 권한 2개를 모두 가진 사용자만 접근할 수 있다. 여기에서도 마찬가지로 hasRole 표현식을 사용하기 때문에 접두어 "ROLE_"이 필요없다.
- (5) 그 외 URL에 대해서는 인증된 사용자만 접근할 수 있다.

<br/><br/><br/>

### 5.5. 로그아웃
[```WebSecurityConfigurerAdapter```](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html)를 사용하면 로그아웃 기능이 자동으로 적용된다. 기본적으로 ```/logout URL```로 접근하면 아래와 같이 진행되어 사용자가 로그아웃 된다.
- HTTP 세션을 무효화시킨다.
- RememberMe 인증 설정을 모두 초기화한다.
- ```SecurityContextHolder```를 초기화한다.
- ```/login?logout```로 리다이렉트 시킨다.

하지만 로그인 기능을 설정하는 것과 마찬가지로 로그아웃 기능도 커스터마이징이 가능하게 옵션들이 준비되어 있다.

```java
protected void configure(HttpSecurity http) throws Exception {
	http
		.logout()                                                                //1
			.logoutUrl("/my/logout")                                                 //2
			.logoutSuccessUrl("/my/index")                                           //3
			.logoutSuccessHandler(logoutSuccessHandler)                              //4
			.invalidateHttpSession(true)                                             //5
			.addLogoutHandler(logoutHandler)                                         //6
			.deleteCookies(cookieNamesToClear)                                       //7
			.and()
		...
}
```

- (1) 로그아웃 기능을 제공한다. WebSecurityConfigurerAdapter를 사용하면 자동으로 적용된다.
- (2) 로그아웃 URL을 설정한다 (기본값은 /logout). CSRF 방어를 사용(기본값)한다면 요청은 POST방식이어야 한다. 더 자세한 정보를 원한다면 [JavaDoc](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-)을 참고하는 것이 좋다.
- (3) 로그아웃 이후에 리다이렉트할 URL을 설정한다. 기본값은 /login?logout 이다. 더 자세한 정보를 원한다면 [JavaDoc](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-)을 참고하는 것이 좋다.
- (4) 사용자 정의 LogoutSuccessHandler를 지정한다. 이 값을 지정하면 logoutSuccessUrl() 설정을 무시된다. 더 자세한 정보를 원한다면 [JavaDoc](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-)을 참고하는 것이 좋다.
- (5) 로그아웃할 때 HttpSession을 무효화할지의 여부를 설정한다. 기본값은 __true__이다. 이 메서드는 암묵적으로 SecurityContextLogoutHandler를 설정한다. 더 자세한 정보를 원한다면 [JavaDoc](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-)을 참고하는 것이 좋다.
- (6) LogoutHandler를 추가한다. SecurityContextLogoutHandler는 기본적으로 LogoutHandler 마지막에 추가되어 있다.
- (7) 로그아웃이 성공 시 삭제할 쿠키의 이름을 지정한다. 이것은 CookieClearingLogoutHanlder를 명시적으로 추가하는 쉬운 방법이다.

> 물론 XML 네임스페이스 표기법을 사용하여 로그아웃을 구성할 수도 있다. 자세한 내용은 Spring Security XML 네임스페이스 절의 [logout 요소](#41126-logout) 대한 내용을 참고하면 된다.

일반적으로 로그아웃 기능을 커스터마이징 하기 위해서 [```LogoutHandler```](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html) 또는 [```LogoutSuccessHandler```](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html) 구현을 추가할 수 있다. 잘 만들어진 API를 사용하면 이러한 handler들은 암묵적으로 적용된다.

<br/>

### 5.5.1. LogoutHandler
일반적으로 [LogoutHandler](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/LogoutHandler.html) 구현체는 로그아웃 처리에 참여할 수 있는 클래스이다. 필요한 정리 작업을 진행하기 위해 호출된다. 따라서 예외(Exception)을 클래스 밖으로 던져서는 안된다. 다양한 구현체들이 제공되고 있다.
- [PersistentTokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html)
- [TokenBasedRememberMeServices](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html)
- [CookieClearingLogoutHandler](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html)
- [CsrfLogoutHandler](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/csrf/CsrfLogoutHandler.html)
- [SecurityContextLogoutHandler](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html)

자세한 내용은 [17.4. Remember-Me 인터페이스와 구현](#174-remember-me-인터페이스와-구현)를 참고하면 된다.

잘 만들어진 API는 ```LogoutHandler``` 구현체를 직접 제공하는 대신 ```LogoutHandler``` 구현체를 암묵적으로 사용할 수 있는 다양하고 쉬운 방법을 제공한다. 예를 들어, ```deleteCookies()```는 로그아웃 성공 시 삭제할 1개 이상의 쿠키 이름을 지정할 수 있도록 해준다. 이는 CookieClearingLogoutHandler를 직접 추가하는 것과 다르게 쉬운 방법이다.

<br/>

### 5.5.2. LogoutSuccessHandler
```LogoutSuccessHandler```는 ```LogoutFilter```에 의해 로그아웃이 성공한 후에 리다이렉션 또는 적절한 목적지로의 이동을 처리하기 위해 호출된다. LogoutSuccessHandler는 ```LogoutHandler```와 거의 같은 인터페이스이지만 예외(Exception)을 발생시킬 수 있다. ([5.5.1. LogoutHandler](#551-logouthandler) 참고)

제공되는 LogoutSuccessHandler 인터페이스의 구현체들은 아래와 같다.
- [SimpleUrlLogoutSuccessHandler](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/apidocs/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html)
- HttpStatusReturningLogoutSuccessHandler

위에서 언급했던 바와 같이, 직접 ```SimpleUrlLogoutSuccessHandler```을 지정하지 않아도 된다. 그 대신 잘 만들어진 API가 ```logoutSuccessUrl()``` 메서드를 제공한다. 이것을 사용하면 암묵적으로 ```SimpleUrlLogoutSuccessHandler```가 설정된다. 로그아웃 이후에 설정한 URL로 리다이렉션된다. 기본값은 ```/login?logout```이다.

```HttpStatusReturningLogoutSuccessHandler```은 REST API 타입 시나리오에서 사용할 수 있다. ```LogoutSuccessHandler```를 사용하면 로그아웃이 성공할 경우 어떤 URL로 리다이렉션하는 것 대신 일반 HTTP 상태코드를 반환해준다. 설정하지 않은 경우 기본적으로 로그아웃 성공에 대한 상태코드는 200을 반환한다.

<br/>

### 5.5.3. 로그아웃 관련 참고사항
- [6.2.4. 로그아웃 처리](#624-로그아웃-처리)
- [12.3.2. 로그아웃 테스트하기](#1232-로그아웃-테스트하기)
- [15.2.3. HttpServletRequest.logout()](#1523-httpservletrequestlogout)
- [17.4. Remember-Me 인터페이스와 구현](#174-remember-me-인터페이스와-구현)
- 18.5. CSRF 주의사항 절의 [18.5.3 Logging Out](#1853-logging-out) 내용
- [32.3.2. Single Logout](#3232-single-logout) (CAS protocol)
- Spring Security XML 네임스페이스 절의 [logout 요소](#41126-logout)에 대한 내용

<br/><br/><br/>

### 5.6. 인증 (Authentication)
지금까지 가장 기본적인 인증 설정에 대해서만 살펴보았다. 이제 인증 설정에 대한 몇 가지 고급 옵션들을 살펴보자.


### 5.6.1. 메모리를 이용한 인증 (In-Memory Authentication)
이미 단일 사용자에 대해 메모리 내에서 인증을 할 수 있도록 설정하는 예제를 살펴봤었다.<sup>[#7](WebSecurityConfig)</sup> 여러 사용자를 설정하고자 한다면 아래 예제를 참고하자.

```java
@Bean
public UserDetailsService userDetailsService() throws Exception {
	InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
	manager.createUser(User.withUsername("user").password("password").roles("USER").build());
	manager.createUser(User.withUsername("admin").password("password").roles("USER","ADMIN").build());
	return manager;
}
```

<br/>

### 5.6.2. JDBC 인증 (JDBC Authentication)<sup id="footkey8">[#8](#footnote8)</sup>
JDBC 기반 인증을 지원하도록 설정할 수 있다. 아래 예제는 이미 어플리케이션에 ```DataSource```를 정의했다는 가정하에 작성된 예제이다. [jdbc-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/jdbc) 샘플은 JDBC 기반 인증 사용에 대한 예제를 제공한다.

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.jdbcAuthentication()
			.dataSource(dataSource)
			.withDefaultSchema()
			.withUser("user").password("password").roles("USER").and()
			.withUser("admin").password("password").roles("USER", "ADMIN");
}
```

__<sub id="footnote8">#8</sub>__ <sub>데이터베이스 안에 [부록 - 40.1. User Schema](#401-user-schema)와 같이 테이블을 구성하고 값을 넣으면 위와 같이 사용할 수 있다. 또한 데이터베이스 안에 저장된 사용자 정보와 함께 withUser()설정로 설정한 user/password, admin/password 사용자도 사용할 수 있다. -옮긴이 ([읽던 곳으로 돌아가기](#footkey8))</sub>

<br/>

### 5.6.3. LDAP<sup id="footkey9">[#9](#footnote9)</sup> 인증 (LDAP Authentication)
LDAP 기반 인증을 지원할 수도 있다. [ldap-javaconfig](https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/ldap) 샘플은 LDAP 기반 인증에 대한 예제를 제공한다.

```java
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.ldapAuthentication()
			.userDnPatterns("uid={0},ou=people")
			.groupSearchBase("ou=groups");
}
```
위의 예제는 아래와 같은 LDIF와 내장된 Apache DS LDAP 인스턴스를 사용한다.

__users.ldif__
```
dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
```

__<sub id="footnote9">#9</sub>__ <sub>LDAP란, Lightweight Directory Access Protocol의 약어로 TCP/IP에서 디렉터리 서비스를 조회하고 수정하는 응용 프로토콜이다. 여기에서 디렉터리란 논리, 계급 방식 속에서 조직화된, 비슷한 특성을 가진 객체들의 모임을 뜻한다. (참고: https://ko.wikipedia.org/wiki/LDAP) -옮긴이 ([읽던 곳으로 돌아가기](#footkey9))</sub>

<br/>

### 5.AuthenticationProvider
사용자 정의 ```AuthenticationProvider```를 Bean으로 노출시킴으로써 인증(Authentication)을 커스터마징할 수 있다. 예를 들어, 다음은 ```SpringAuthenticationProvider```가 ```AuthenticationProvider```의 구현체라고 가정하고 인증을 커스터마이징한 예제이다.

> 이는 ```AuthenticationManagerBuilder```를 사용하지 않는 경우에만 사용한다.

```java
@Bean
public SpringAuthenticationProvider springAuthenticationProvider() {
	return new SpringAuthenticationProvider();
}
```

<br/>

### 5.6.5. UserDetailsService
사용자 정의 UserDetailsService를 Bean으로 노출시킴으로써 인증(Authentication)을 커스터마이징할 수 있다. 예를 들어, ```SpringDataUserDetailsService```가 ```UserDetailsService```의 구현체라고 가정하고 인증을 커스터마이징한 예제이다.

> 이는 ```AuthenticationManagerBuilder```를 사용하지 않고 ```AuthenticationProviderBean```이 정의되지 않은 경우에만 사용한다.

```java
@Bean
public SpringDataUserDetailsService springDataUserDetailsService() {
	return new SpringDataUserDetailsService();
}
```

PasswordEncoder를 bean으로 노출시킴으로써 암호가 인코딩되는 방식을 커스터마이징할 수 있다. 예를 들어, bcypt를 사용하고자 하는 경우 아래와 같이 bean 정의를 추가할 수 있다.

```java
@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}
```

<br/><br/><br/>

### 5.7. 다중 HttpSecurity
XML 네임스페이스에서 여러 개의 <http> 블럭을 가질 수 있는 것처럼 여러 개의 HttpSecurity 인스턴스를 설정할 수 있다. 핵심은 WebSecurityConfigurerAdapter를 여러 번 상속하는 것이다. 아래 예제는 ```/api/```로 시작하는 URL에 대한 상이한 설정을 하는 예제이다.

```java
@EnableWebSecurity
public class MultiHttpSecurityConfig {
	@Bean
	public UserDetailsService userDetailsService() throws Exception {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withUsername("user").password("password").roles("USER").build());
		manager.createUser(User.withUsername("admin").password("password").roles("USER","ADMIN").build());
		return manager;
	}

	@Configuration
	@Order(1)                                                        //1
	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
		protected void configure(HttpSecurity http) throws Exception {
			http
				.antMatcher("/api/**")                               //2
				.authorizeRequests()
					.anyRequest().hasRole("ADMIN")
					.and()
				.httpBasic();
		}
	}

	@Configuration                                                   //3
	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.formLogin();
		}
	}
}
```
정상적으로 인증을 설정한다.
- (1) 어떤 WebSecurityConfigurerAdapter가 가장 먼저 고려되어야 하는지를 명시하는 어노테이션 @Order가 포함된 WebSecurityConfigurerAdapter의 인스턴스를 생성한다.
- (2) http.antMatcher는 HttpSecurity가 /api/로 시작하는 URL에만 적용되도록 설정한다.
- (3) WebSecurityConfigurerAdapter의 또 다른 인스턴스를 생성한다. URL이 /api/로 시작하지 않으면 이 설정을 사용한다. 이 설정은 @Order 값이 1보다 크기 때문에 ApiWebSecurityConfigurationAdapter 이후에 고려된다. (@Order의 정해진 기본값은 없다.<sup id="footkey10">[#10](#footnote10)</sup>)

__<sub id="footnote10">#10</sub>__ <sub>[어노테이션 @Order](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/Order.html)의 기본값을 살펴보면 [Ordered.LOWEST_PRECEDENCE](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/Ordered.html#LOWEST_PRECEDENCE)라고 명시되어 있다. 이 값은 우선순위가 가장 낮은 값을 의미하는데 상황에 따라 우선순위가 낮은 값은 계속해서 변경되기 때문에 정해진 기본값이 없는 것과 같다.  -옮긴이 ([읽던 곳으로 돌아가기](#footkey10))</sub>

<br/><br/><br/>

### 5.8. 메서드 Security (Method Security)
Spring Security는 버전 2.0부터 서비스 계층 메서드에 보안을 추가하기 위해 상당히 많은 부분을 발전시켜왔다. 프레임워크의 ```@Secured``` 어노테이션 뿐만 아니라 JSR-250 어노테이션 security 지원을 제공하고 있다. 3.0부터는 [표현식 기반 어노테이션](https://docs.spring.io/spring-security/site/docs/4.2.3.RELEASE/reference/htmlsingle/#el-access)을 사용할 수도 있게 되었다. ```intercept-methods``` 요소를 사용하여 하나의 Bean에 security를 적용할 수도 있고, AspectJ 스타일 pointcut을 사용하여 전체 서비스 계층에 걸쳐 있는 여러 bean에 security를 적용할 수도 있다.

### 5.8.1. EnableGlobalMethodSecurity
어떤 ```@Configuration``` 인스턴스든 ```@EnableGlobalMethodSecurity```를 사용하여 어노테이션 기반 security를 사용할 수 있다. 아래 예제는 Spring Security의 ```@Secured``` 어노테이션을 활성화하는 예제이다.

```java
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

클래스 또는 인터페이스에 있는 메서드에 어노테이션을 추가하면 그에 따라 해당 메서드에 대한 접근이 제한된다. Spring Security의 어노테이션은 메서드 속성들을 정의한다. 이는 접근 제어에 대한 결정이 필요할 때 AccessDecisionManager에 전달된다.

```java
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
```

JSR-250 어노테이션은 아래와 같이 활성화할 수 있다.

```java
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
```

설명한 기능들은 표준 기반이고 간단한 권한 기반 제약을 적용할 수 있지만 강력한 Spring Security의 어노테이션은 포함하고 있지 않다. 새로운 표현식 기반 구문을 사용하려면 아래와 같이 하면 된다.

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
```

Java 코드 또한 아래와 같이 변경하면 된다.

```java
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
```

<br/>

### 5.8.2. GlobalMethodSecurityConfiguration
때로는 ```@EnableGlobalMethodSecurity``` 어노테이션이 허용으로 가능한 부분보다 더 복잡한 작업들을 해야 할 때가 있다. 이러한 경우, 자식 클래스에 ```@EnableGlobalMethodSecurity``` 어노테이션이 있는지 확인하는 ```GlobalMethodSecurityConfiguration```을 상속하면 된다. 예를 들어, 커스터마이징한 ```MethodSecurityExpressionHandler```를 제공하고자 하는 경우 아래와 같은 설정을 사용할 수 있다.

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... 커스터마이징한 MethodSecurityExpressionHandler를 생성하고 리턴 ...
		return expressionHandler;
	}
}
```

재정의 할 수 있는 메서드에 대한 추가적인 정보는 [```GlobalMethodSecurityConfiguration``` Javadoc](https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/annotation/method/configuration/GlobalMethodSecurityConfiguration.html)을 참고하는 것이 좋다.

<br/><br/><br/>

### 5.9. 설정 객체의 수정/대체
Spring Security의 Java 설정은 설정하는 모든 객체의 모든 속성을 노출시키지는 않는다. 이는 대다수 사용자들이 설정을 간단하게 할 수 있도록 한다. 어쨌든 모든 속성이 노출되면 사용자들은 표준 bean 설정을 사용할 수 있게 된다.

모든 속성을 직접 노출하지 않는 것이 좋은 면은 있지만, 사용자는 고급 설정 옵션이 필요할 수 있다. 그래서 Java 설정에 의해 생성된 많은 객체 인스턴스를 수정하거나 대체하기 위해 사용되는 ```ObjectPostProcessor```의 개념을 소개하고자 한다. 예를 들어, ```FilterSecurityInterceptor```의 ```filterSecurityPublishAuthorizationSuccess```속성을 설정하고자 한다면 아래와 같이 하면 된다.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
				public <O extends FilterSecurityInterceptor> O postProcess(O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			});
}
```

<br/>

### 5.10. DSL 커스터마이징하기
Spring Security를 통해 자신만의 DSL을 제공할 수도 있다. 예를 들어, 아래와 같은 예제가 있을 수 있다.

```java
public class MyCustomDsl extends AbstractHttpConfigurer<CorsConfigurerMyCustomDsl, HttpSecurity> {
	private boolean flag;

	@Override
	public void init(H http) throws Exception {
		// any method that adds another configurer
		// must be done in the init method
		http.csrf().disable();
	}

	@Override
	public void configure(H http) throws Exception {
		ApplicationContext context = http.getSharedObject(ApplicationContext.class);

		// here we lookup from the ApplicationContext. You can also just create a new instance.
		MyFilter myFilter = context.getBean(MyFilter.class);
		myFilter.setFlag(flag);
		http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
	}

	public MyCustomDsl flag(boolean value) {
		this.flag = value;
		return this;
	}

	public static MyCustomDsl customDsl() {
		return new MyCustomDsl();
	}
}
```

> 이는 실제로 ```HttpSecurity.authorizeRequests()```와 같은 메소드가 구현되는 방법이다.

위와 같이 하면 커스터마이징한 DSL을 아래와 같이 사용할 수 있다.

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl())
				.flag(true)
				.and()
			...;
	}
}
```

위의 코드는 아래 순서대로 호출된다.
- 'Config'의 configure 메서드 안의 코드가 호출된다.
- 'MyCustomDsl'의 init 메서드 안의 코드가 호출된다.
- 'MyCustomDsl'의 configure 메서드 안의 코드가 호출된다.

원한다면 ```SpringFactories```를 사용하여 기본적으로 ```WebSecurityConfigurerAdapter```에 ```MyCustomDsl```을 추가할 수 있다. 예를 들어, 아래와 같이 META-INF/spring.factories라는 클래스 패스에 리소스를 생성하면 된다.

__META-INF/spring.factories__
```
org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl
```

기본 설정을 사용하지 않고 싶다면 명시적으로 설정할 수 있다.

```java
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl()).disable()
			...;
	}
}
```

<br/><br/><br/><br/>

## 6. Security 네임스페이스 설정

### 6.1. 소개
Spring Security 버전 2.0부터 네임스페이스 설정을 사용할 수 있다. 추가적인 XML 스키마 요소로 이전 Spring bean 어플리케이션 context 구문을 보완할 수 있다. [Spring 레퍼런스 문서](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/)에서 더 많은 정보를 찾을 수 있다. 네임스페이스 요소는 보다 간결하게 개별 bean 설정하는 데에 쉽게 사용될 수 있다. 또한 문제 영역(problem domain)<sup id="footkey14">[#14](#footnote14)</sup>과 밀접하게 일치하는 대체 설정 구문을 정의하거나 기본 복잡성을 사용자에게 노출하지 않는데 사용될 수 있다. 간단한 XML 요소는 다중 bean 또는 처리 단계가 어플리케이션 context에 추가되는 것을 눈에 보이지 않게 처리한다. 예를 들어, 어플리케이션 context에 아래 security 네임스페이스 요소를 추가하는 것은 어플리케이션 안에서 테스트용으로 사용될 내장 LDAP 서버를 시작하게 한다.

```xml
<security:ldap-server />
```

이는 동일한 Apache Directory Server bean을 연결하는 것보다 훨씬 간단하다. 가장 일반적인 설정 요구사항들은 ```ldap-server``` 요소의 속성으로 지원되고 사용자는 작성해야 하는 bean과 bean의 프로퍼티 이름이 무엇인지 걱정하지 않아도 된다<sup id="footkey_r_1">[[1]](#footnote_r_1)</sup>. 어플리케이션 context 파일 편집할 때 좋은 XML 편집기를 사용하면 사용가능한 요소와 속성들에 대한 정보를 얻을 수 있다. Spring Tool Suite에는 표준 Spring 네임스페이스로 작업할 때 사용할 수 있는 특별한 기능이 있기 때문에 이것을 사용할 것을 추천한다.

어플리케이션 context에서 security 네임스페이스를 사용하려면 classpath에 ```spring-security-config``` jar가 있어야 한다. 그 다음 어플리케이션 context file에 아래와 같이 스키마 선언을 추가하면 된다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		http://www.springframework.org/schema/security/spring-security.xsd">
	...
</beans>
```

많은 예제에서 볼 수 있듯이(그리고 샘플 어플리케이션에서도 볼 수 있듯이) 기본 네임스페이스로 "beans"보다는 "security"를 더 많이 사용한다. 이는 모든 security 네임스페이스 요소에서 접두어를 생략할 수 있고 내용을 읽기 쉬워서 그렇다고 할 수 있다. 어플리케이션 context를 여러 파일로 분리하고 그 중 하나에 security 설정 대부분을 넣는 경우에도 이렇게 네임스페이스 설정을 사용할 수 있다. 다음 예제는 security 어플리케이션 context 파일 설정이다.

```xml
<beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/security
		http://www.springframework.org/schema/security/spring-security.xsd">
	...
</beans:beans>
```

이 장에서 지금부터 이 구문을 사용한다고 가정하자.

__<sub id="footnote14">#14</sub>__ <sub>문제 영역, 즉 problem domain이라는 것은 위키피디아 설명을 참고하자면 문제를 해결하기 위해 검사해야 하는 전문지식의 영역 또는 어플리케이션의 영역이다. 이렇게 설명을 읽고 나서도 정확히 무엇을 말하는 건지 이해하기 쉽지 않을 수 있다. 예를 들어보자. 내가 만약 사진을 판매하는 웹 사이트를 만든다고 하면 나의 문제 영역은 사진과 전자상거래라고 할 수 있다. 문제를 풀기 위한 중요한 이슈, 주제? 정도로 생각하면 된다. 이 레퍼런스에서 설명하는 문제영역은 말 그대로 '내가 해결하고자 하는 이슈'라고 이해하면 된다. 따라서 '문제영역과 밀접하게 일치하는 대체 설정 구문'은 내가 해결하고자 하는 이슈를 잘 표현한, 잘 구조화시킨 대체 설정구문 정도로 이해하면 될 것으로 보인다. -옮긴이 ([읽던 곳으로 돌아가기](#footkey14))</sub>

<br/>

### 6.1.1. 네임스페이스 설계
네임스페이스는 프레임워크의 가장 일반적으로 사용되도록 설계되었으며, 어플리케이션 내에서 사용할 수 있도록 간단하고 간결한 구문을 제공하도록 설계되었다. 설계는 프레임워크 내의 대규모의 의존성을 기반으로 하며 다음과 같은 영역으로 나눌 수 있다.

- Web/HTTP Security - 가장 복잡한 부분이다. 프레임워크 인증 메커니즘을 적용하고 URL을 보호하고 로그인 또는 에러 페이지를 렌더링 하는 등에 사용되는 필터 및 관련 서비스 bean을 설정한다.
- Business Object (Method) Security - 서비스 계층을 보호하기 위한 옵션이다.
- AuthenticationManager - 프레임워크의 다른 부분에서 인증요청을 처리한다.
- AccessDecisionManager - 웹 및 메소드 보안에 대한 접근을 결정한다. 기본 설정이 등록되지만 기본 Spring Bean 구문을 사용해 선언한 맞춤 설정을 사용하도록 선택할 수도 있다.
- AuthenticationProviders - 인증 관리자가 사용자를 인증하는 메커니즘이다. 네임스페이스는 몇 가지 표준 옵션과, 예전방식의 구문으로 선언된 커스터마이징한 bean을 추가하는 방법을 제공한다.
- UserDetailsService - 인증 공급자와 밀접한 관계가 있지만 다른 bean에서도 필요로 한다.

다음 섹션에서는 이것들을 설정하는 방법을 살펴보자.

<br/><br/><br/>

### 6.2. Security 네임스페이스 설정 시작하기
이 섹션에서는 프레임워크의 주요기능 중 일부를 사용하기 위해 네임스페이스를 설정하는 방법을 살펴볼 것이다. 처음에는 최대한 빨리 어플리케이션을 실행하고 몇 번의 테스트 로그인을 통해 기존 웹 어플리케이션에 인증 및 접근 제어를 추가하려는 경우를 살펴볼 것이다. 그리고나서 데이터베이스 또는 기타 보안 저장소에 대한 인증으로 변경하는 방법을 살펴볼 것이다. 이후 섹션에서는 고급 네입스페이스 설정 옵션을 소개할 것이다.

<br/>

### 6.2.1. web.xml 설정
제일 먼저 해야 할 것은 ```web.xml``` 파일에 아래와 같이 필터 선언을 추가하는 작업이다.

```xml
<filter>
<filter-name>springSecurityFilterChain</filter-name>
<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>

<filter-mapping>
<filter-name>springSecurityFilterChain</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
```

이 설정은 Spring Security 웹 인프라에 연결고리를 제공한다. ```DelegatingFilterProxy```는 어플리케이션 context에서 Spring bean으로 정의된 필터를 위임하는 Spring 프레임워크 클래스이다. 이러한 경우 bean은 "springSecurityFilterChain"으로 명명하며 이것은 웹 보안을 처리하기 위해 네임스페이스에 의해 생성된 내부 인프라 bean이다. 이 bean의 이름을 직접 사용해서는 안된다. 이것을 ```web.xml```에 추가하면 어플리케이션 context 파일 편집을 시작할 준비가 되었다고 할 수 있다. 웹 보안 서비스는 ```<http>``` 요소를 사용하여 설정한다.

<br/>

### 6.2.2. 최소한의 ```<http>``` 설정

웹 보안을 시작하는데 필요한 것은 아래와 같다.

```xml
<http>
  <intercept-url pattern="/**" access="hasRole('USER')" />
  <form-login />
  <logout />
</http>
```

이는 어플리케이션의 모든 URL이 보호되고, URL에 접근하기 위해서는 ```ROLE_USER``` 권한이 필요하며, 사용자명과 비밀번호로 폼로그인을 할 수 있고, 로그아웃 URL을 등록하여 사용할 수 있다는 의미이다. ```http``` 요소는 모든 웹 관련 네임스페이스 기능의 부모 요소이다. ```<intercept-url>``` 요소는 ant 경로 표시 스타일을 사용하여 들어오는 요청과 일치하는 ```pattern```을 정의한다<sup id="footkey_r_2">[[2]](#footnote_r_2)</sup>. 또한 대안으로 정규표현식 매칭을 사용할 수도 있다(자세한 내용은 네임스페이스 부록을 참고). ```access``` 속성은 주어진 패턴과 일치하는 요청에 대한 접근 요구사항을 정의한다. 기본 설정에 의하면 이는 전형적으로 컴마 구분의 리스트로 되어있고 사용자는 이중 하나의 권한에 일치되어야 요청을 허용받을 수 있다. 접두어 "ROLE_"은 사용자 권한과 간단한 비교과정이 있어야 된다는 표식이다. 즉, 일반적인 권한 기반 확인이 사용된다. Spring Security의 접근 제어는 단순히 권한 제어에 국한되어 있지 않다(따라서 다양한 유형의 보안 속성을 구별하기 위해 접두어를 사용한다). 추후에 이러한 해석이 어떻게 다음과 같은 각주를 변화시킬 수 있는지 확인할 것이다. [```access``` 속성 내에 컴마로 구분된 값들의 해석은 사용되는 -1--의 구현에 따라 달라진다. Spring Security 3.0 에서 그 속성은 또한 -2--로도 채워질 수 있다.]

> 여러 개의 ```<intercept-url>``` 요소를 사용하여 서로 다른 URL 집합에 대한 서로다른 접근 요구사항을 정의할 수 있다. 하지만 나열된 순서대로 적용되고 첫 번째 일치하는 요구사항이 사용될 것이다. 따라서 가장 구체적으로 일치하는 요구사항을 맨 처음에 위치 시켜야 한다. 또한 메소드 속성을 추가하여 특정 HTTP 메소드(GET, POST, PUT 등)와 일치하는 값만 허용하도록 제한할 수 있다.

일부 사용자들을 추가하기 위해 아래와 같이 네임스페이스에서 직접 테스트 데이터 세트를 정의할 수 있다.

```xml
<authentication-manager>
  <authentication-provider>
  	<user-service>
    	<user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" />
    	<user name="bob" password="bobspassword" authorities="ROLE_USER" />
  	</user-service>
  </authentication-provider>
</authentication-manager>
```

프레임워크의 이전 네임스페이스 버전이 익숙하다면 아마도 이미 이러한 부분들이 어떤 작업을 하는 것인지 대략 짐작할 수 있을 것이다. ```<http>``` 요소는 ```FilterChainProxy```와 필터 bean을 만드는 역할을 담당한다. 잘못된 필터 순서와 같은 일반적인 문제는 필터 위치가 미리 정의되어 있으므로 더 이상 문제가 되지 않는다.

```<authentication-provider>``` 요소는 ```DaoAuthenticationProvider``` bean을 만들고 ```<user-service>``` 요소는 ```InMemoryDaoImpl```을 만든다. 모든 ```authentication-provider``` 요소들은 ```ProviderManager```를 만들고 이와 함께 authentication provider를 등록하는 ```<authentication-manager>``` 요소의 하위 요소이다. 네임스페이스 부록에서 생성된 bean에 대한 자세한 정보를 참고하면 된다. 추후에 프레임워크에서 중요한 클래스가 무엇이고 어떻게 사용되는지 이해하고 싶거나, 특히 커스터마이징하고 싶은 부분이 있다면 부록을 함께 확인하는 것이 좋다.

상기 설정은 어플리케이션 내에 두 개의 사용자, 비밀번호, 권한(접근 제어에 사용됨)을 정의하는 것이다. ```user-service```의 ```properties``` 속성을 사용하여 표준 properties 파일에서 사용자 정보를 불러오는 것도 가능하다. 파일 형식에 대한 자세한 내용은 [10.2.1. 메모리상 인증(In-Memory Authorization)](#1021-메모리상-인증in-memory-authorization) 섹션을 참고하면 된다. ```<authentication-provider``` 요소를 사용한다는 것은 사용자 정보가 인증 관리자의 인증 처리 과정에 사용된다는 것을 의미한다. 여러 인증 출처를 정의하고 각각 차례대로 참조할 수 있게 여러 개의 ```<authentication-provider>``` 요소를 설정할 수 있다.

이때 어플리케이션을 시작할 수 있어야 하고 게속 진행하려면 로그인을 해야 한다. 시험해 보거나 프로젝트와 함께 제공되는 튜토리얼 샘플 어플리케이션을 사용해 보기를 권한다.

<br/>

### 6.2.3. Form과 기본적인 로그인 옵션
HTML 파일이나 JSP에 대한 언급이 없기 때문에 로그인하라는 메시지가 표시되었을 때 로그인 폼이 어디서 왔는지 궁금할 수 있다. 사실 로그인 페이지에 대한 URL을 명시적으로 설정하지 않았기 때문에 Spring Security는 활성화된 기능을 기반으로 전송된 로그인 요청을 처리하는 URL에 대한 표준값을 사용하여 자동으로 로그인 url을 하나 생성한다. 네임스페이스는 이러한 옵션들을 커스터마이징 할 수 있도록 지원한다. 예를 들어, 자신의 로그인 페이지를 사용하려면 아래와 같이 설정하면 된다.

```xml
<http>
  <intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
  <intercept-url pattern="/**" access="ROLE_USER" />
  <form-login login-page='/login.jsp'/>
</http>
```

```intercept-url``` 요소가 하나 더 추가된 것을 볼 수 있다. 이는 로그인 페이지에 대한 어떤 요청이든 익명의 사용자<sup id="footkey_r_3">[[3]](#footnote_r_3)</sup>에게 사용할 수 있도록 해주는 것을 의미하며, ```IS_AUTHENTICATED_ANONYMOUSLY``` 값이 어떻게 처리되는지에 대한 상세 명세인 [AuthenticatedVoter](#authenticatedvoter) 클래스 또한 이를 사용할 수 있다. 이렇게 설정하지 않으면 요청은 패턴 /**에 일치한다고 보며 로그인 페이지 자체에 접근할 수 없다. 이는 일반적인 설정 오류이므로 어플리케이션에 무한 루프가 발생한다. Spring Security는 로그인 페이지가 보안설정이 되어 있는 것으로 판단되면 로그에 경고를 표시한다. 또한 특정 패턴과 일치하는 모든 요청을 아래과 같이 패턴에 대한 별도의 ```http``` 요소를 정의하여 보안 필터체인을 우회하도록 설정할 수도 있다.

```xml
<http pattern="/css/**" security="none"/>
<http pattern="/login.jsp*" security="none"/>

<http use-expressions="false">
<intercept-url pattern="/**" access="ROLE_USER" />
<form-login login-page='/login.jsp'/>
</http>
```

Spring Security 3.1부터는 서로 다른 요청 패턴에 대한 분리된 보안 필터 체인 설정을 하기 위해 다중 ```http``` 요소를 사용할 수 있다. ```http``` 요소에서 ```pattern``` 속성을 생략하면 모든 요청과 일치하는 것으로 간주한다. 보안설정하지 않은 패턴을 생성하는 것은 이 구문의 간단한 예이며, 패턴은 비어있는 필터 체인<sup id="footkey_r_4">[[4]](#footnote_r_4)</sup>에 매핑된다. 이 새로운 구문은 [13.6. 고급 네임스페이스 설정](#136-고급-네임스페이스-설정)에서 더 자세히 다룰 것이다.

이러한 보안설정되지 않은 요청은 Spring Security 웹 관련 설정이나 ```requires-channel```과 같은 추가적인 속성을 완전히 인식하지 못하기 때문에 요청 시 현재 사용자의 정보에 접근하거나 보안 메소드를 호출할 수 없다. 보안 필터 체인을 적용하려면 ```access='IS_AUTHENTICATED_ANONYMOUSLY'```를 사용하면 된다.

폼 로그인 대신 기본 인증을 사용하려면 설정을 아래와 같이 변경한다.

```xml
<http use-expressions="false">
  <intercept-url pattern="/**" access="ROLE_USER" />
  <http-basic />
</http>
```

기본 인증이 우선적용되고 사용자가 보호되는 리소스에 접근하려고 시도하면 로그인하라는 메시지가 표시된다. 폼 로그인은 다른 웹 페이지에 포함된 로그인 폼을 사용하기를 원하는 경우 이렇게 설정하면 된다.

### 로그인 성공 후 전환되는 페이지 정보 설정
보호된 리소스에 접근하려고 시도하여 폼 로그인이 표시되지 않으면 ```default-target-url``` 옵션이 작동한다. 이는 성공적으로 로그인 한 후 사용자가 이동하게되는 URL이며 기본값은 "/"이다. ```always-use-default-target``` 속성을 "true"로 설정하여 사용자가 항상 (로그인이 "on-demand"인지 또는 명시적으로 로그인하도록 선택했는지는 관계없이) 이 페이지에서 끝나도록 설정할 수 있다. 이는 어플리케이션에서 항상 사용자가 "home" 페이지로 시작하게 해야 하는 경우 유용하다. 예를 들면 다음과 같다.

```xml
<http pattern="/login.htm*" security="none"/>
<http use-expressions="false">
  <intercept-url pattern='/**' access='ROLE_USER' />
  <form-login login-page='/login.htm' default-target-url='/home.htm' always-use-default-target='true' />
</http>
```

목적지를 더욱 효과적으로 제어하려면 ```default-target-url``` 대신 ```authentication-success-handler-ref``` 속성을 사용할 수 있다. 설정할 참조 bean은 ```AuthenticationSuccessHandler```의 인스턴스여야 한다. [14.4.1. 인증 성공/실패 시 어플리케이션의 흐름](#1441-인증-성공실패-시-어플리케이션의-흐름)와 네임스페이스 부록에서 이에 대한 자세한 내용과 인증 실패 시 흐름을 커스터마이징하는 방법을 찾아볼 수 있다.

<br/>

### 6.2.4. 로그아웃 처리
```logout``` 요소는 특정 URL로 이동하여 로그아웃하는 것을 지원한다. 기본 로그아웃 URL은 ```/logout```이지만 ```logout-url``` 속성을 사용하여 다른 로그아웃 URL을 설정할 수 있다. 다른 사용가능한 속성에 대한 자세한 내용은 네임스페이스 부록을 참고하면 된다.

<br/>

### 6.2.5. 다른 인증 공급자 사용하기
실제로 어플리케이션 context 파일에 추가된 몇 가지 사용자명보다 더 많은 확장성이 좋은 사용자 정보 소스가 필요하다. 대부분 데이터베이스 또는 LDAP 서버와 같은 곳에 사용자 정보를 저장하려고 한다. LDAP 네임스페이스 설정은 [29. LDAP 인증 (LDAP Authentication)](#29-ldap-인증-ldap-authentication-1)에서 다루므로 여기에서는 다루지 않을 것이다. 어플리케이션 context에서 "myUserDetailsService"라는 Spring Security ```UserDetailsService```의 커스터마이징 구현체를 정의한 경우 아래와 같이 설정하여 인증할 수 있다.

```xml
<authentication-manager>
	<authentication-provider user-service-ref='myUserDetailsService'/>
</authentication-manager>
```

데이터베이스를 사용하면 아래와 같이 설정할 수 있다.

```xml
<authentication-manager>
  <authentication-provider>
  	<jdbc-user-service data-source-ref="securityDataSource"/>
  </authentication-provider>
</authentication-manager>
```

여기에서 "securityDataSource"는 어플리케이션 context에서 표준 Spring Security [사용자 데이터 테이블](#401-user-schema)을 포함하는 데이터베이스를 가리키는 ```DataSource``` bean 이름이다. 또는 Spring Security ```JdbcDaoImpl``` bean을 설정하고 ```user-service-ref``` 속성을 사용하여 이를 참조하게 할 수도 있다.

```xml
<authentication-manager>
  <authentication-provider user-service-ref='myUserDetailsService'/>
</authentication-manager>

<beans:bean id="myUserDetailsService" class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl">
  <beans:property name="dataSource" ref="dataSource"/>
</beans:bean>
```

아래와 같이 표준 ```AutenticationProvider``` bean을 사용할 수도 있다.

```xml
<authentication-manager>
	<authentication-provider ref='myAuthenticationProvider'/>
</authentication-manager>
```

여기에서 ```myAuthenticationProvider```는 ```AuthenticationProvider```를 구현하는 어플리케이션 context bean 이름이다. 여러 인증 공급자 요소를 사용할 수도 있다. 이러한 경우 공급자는 선언된 순서대로 설정된다. 네임스페이스를 사용하여 Spring Security ```AuthenticationManager```를 설정하는 방법에 대한 자세한 정보는 [6.6. 인증 관리자(Authentication Manager)와 네임스페이스](#66-인증-관리자authentication-manager와-네임스페이스)를 참고하면 된다.

### 비밀번호 암호화기(password encoder) 추가하기
비밀번호는 항상 SHA 또는 MD5와 같은 표준 알고리즘이 아닌 특정 목적을 위해 설계된 해싱 보안 알고리즘을 사용하여 인코딩한다. 이는 ```password-encoder``` 요소를 통해 지원된다. bcrypt로 인코딩 된 암호를 사용하는 경우 인증 공급자 설정은 아래와 같다.

```xml
<beans:bean name="bcryptEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>

<authentication-manager>
  <authentication-provider>
  	<password-encoder ref="bcryptEncoder"/>
  	<user-service>
    	<user name="jimi" password="d7e6351eaa13189a5a3641bab846c8e8c69ba39f" authorities="ROLE_USER, ROLE_ADMIN" />
    	<user name="bob" password="4e7421b1b8765d8f9406d87e7cc6aa784c4ab97f" authorities="ROLE_USER" />
  	</user-service>
  </authentication-provider>
</authentication-manager>
```

bcrypt는 다른 알고리즘을 사용하도록 강요하는 레거시 시스템이 아니라면 대부분의 경우 적합하다. 간단한 해시 알고리즘을 사용하거나 심지어 일반 텍스트 비밀번호를 그대로 저장하는 경우 bcrypt와 같은 보다 안전한 옵션으로 마이그레이션하는 것을 고려해봐야 한다.

<br/><br/><br/>

### 6.3. 고급 웹 기능

### 6.3.1. 인증 기억하기
remember-me 네임스페이스 설정에 대한 정보는 별도의 [17. Remember-Me 인증(Authentication)](#17-remember-me-인증authentication-1) 장을 참조.

<br/>

### 6.3.2. HTTP/HTTPS 채널 보안 추가하기
어플리케이션이 HTTP와 HTTPS를 모두 지원하고 HTTPS를 통해서만 특정 URL에 접근할 수 있도록 하는 경우 ```<intercept-url>```의 ```requires-channel``` 속성을 사용하면 된다.

```xml
<http>
  <intercept-url pattern="/secure/**" access="ROLE_USER" requires-channel="https"/>
  <intercept-url pattern="/**" access="ROLE_USER" requires-channel="any"/>
  ...
</http>
```

이 설정을 사용하면 사용자가 HTTP를 사용하여 "/secure/**" 패턴과 일치하는 url에 접근하려고 하면 우선 HTTPS URL<sup id="footkey_r_5">[[5]](#footnote_r_5)</sup>로 리다이렉션 된다. 사용가능한 옵션은 "http", "https", "any"이다. "any"를 사용하면 HTTP, HTTPS 모두 사용할 수 있다는 의미이다.

어플리케이션에서 HTTP, HTTPS에 대해 비표준 포트를 사용하는 경우 아래와 같이 포트 매핑을 설정할 수 있다.

```xml
<http>
  ...
  <port-mappings>
  	<port-mapping http="9080" https="9443"/>
  </port-mappings>
</http>
```

보안을 유지하기 위해서는 어플리케이션이 HTTP를 전혀 사용하지 않던가 아니면 HTTP와 HTTPS간의 전환이 필요하다. HTTPS URL은 사용자가 HTTPS URL을 입력한 상태에서 시작해야 하며 중간자 공격 가능성을 피하기 위해 보안 연결을 사용해야 한다.

<br/>

### 6.3.3. 세션 관리하기

### Timeout 감지하기
유효하지 않은 세션 ID를 감지하고 사용자를 적절한 URL로 리다이렉션하도록 Spring Security를 설정할 수 있다. 아래는 ```session-management``` 요소를 통해 세션 관리를 설정하는 예제이다.

```xml
<http>
  ...
  <session-management invalid-session-url="/invalidSession.htm" />
</http>
```

세션 timeout을 감지하기 위해 이 메커니즘을 사용하면, 사용자가 로그아웃하고 브라우저 종료없이 다시 로그인하는 경우 오류로 인지할 수도 있다는 것을 알아두자. 이는 세션을 무효화시킬 때 세션 쿠키가 지워지지 않아 사용자가 로그아웃했음에도 불구하고 이 세션 쿠키가 다시 전달되기 때문이다. 로그아웃 시 명시적으로 JSESSIONID 쿠키를 삭제할 수도 있다. 예를 들어 로그아웃 핸들러에 아래와 같은 구문을 사용하면 된다.

```xml
<http>
  <logout delete-cookies="JSESSIONID" />
</http>
```

아쉽게도 이것이 모든 서블릿 컨테이너에서 동작한다는 보장이 없으므로 자신의 환경에서 테스트해봐야 한다.

> 프록시 서버 뒤에서 어플리케이션을 실행하고 있다면 프록시 서버에 설정하여 세션 쿠키를 삭제할 수 있다. 예를 들어, Apache HTTPD의 mod_headers를 사용하는 아래 예제는 로그 아웃 요청에 대한 응답에서 ```JSESSIONID``` 쿠키를 만료함으로써 이를 삭제한다. (어플리케이션이 ```/tutorial``` 경로 아래 배포되어 있다고 가정하자.)
> ```xml
> <LocationMatch "/tutorial/logout">
>  Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
> </LocationMatch>
> ```

### 동시 세션 제어하기
한 사용자가 어플리케이션에 로그인하는 것에 대해 제약 조건을 주고자 하는 경우 Spring Security을 사용하면 아래와 같이 간단한 추가 기능으로 즉시 적용할 수 있다. 먼저 Spring Security에게 세션 라이프 사이클 이벤트에 대해 알려주기 위해 ```web.xml```파일에 아래 리스너를 추가해야 한다.

```xml
<listener>
  <listener-class>
  	org.springframework.security.web.session.HttpSessionEventPublisher
  </listener-class>
</listener>
```

그런 다음 어플리케이션 컨텍스트에 아래 줄을 추가한다.

```xml
<http>
  ...
  <session-management>
  	<concurrency-control max-sessions="1" />
  </session-management>
</http>
```

이렇게 하면 사용자가 다중 로그인 하는 것을 방지할 수 있다. 두 번째 로그인으로 인해 첫 번째 로그인은 무효화 된다. 가끔 두 번째 로그인을 막는 것을 더 선호하기도 한다. 그런 경우 아래 코드를 사용하면 된다.

```xml
<http>
  ...
  <session-management>
  	<concurrency-control max-sessions="1" error-if-maximum-exceeded="true" />
  </session-management>
</http>
```

두 번째 로그인은 거부된다. 거부된다는 것은 폼 로그인 하는 경우 사용자가 ```authentication-failure-url```로 이동하게 만든다는 뜻이다. "remember-me"와 같은 비상호적인 메커니즘을 통해 두 번째 인증이 수행되는 경우에는 "승인되지 않았다"는 에러(401)가 사용자에게 전달된다. 에러 페이지를 사용하고자 하는 경우에는 ```session-management``` 요소에 ```session-authentication-error-url``` 속성을 추가하면 된다.

폼 기반 로그인에 커스터마이징한 인증 필터를 사용하는 경우, 동시 세션 제어를 명시적으로 설정해야 한다. 자세한 내용은 [21. 세션 관리 (Session Management)](#21-세션-관리-session-management-1)를 참고하면 된다.

### 세션 강제고정 공격(Session Fixation Attack) 방어하기

[세션 강제고정 공격(Session Fixation Attack)](https://en.wikipedia.org/wiki/Session_fixation)은 악의적인 공격자가 사이트에 접근하여 세션을 생성한 다음 다른 사용자가 같은 세션으로 로그인하도록 유도하는 것을 말한다. (예를 들어, 세션 식별자가 포함된 링크를 사용자에게 매개변수로 보내는 방법을 사용한다.) Spring Security는 새로운 세션을 생성하거나 사용자가 로그인 할 때 세션 아이디를 변경함으로써 자동으로 공격을 방지한다. 이 보호가 필요하지 않거나 다른 요구사항과 충돌하는 경우, ```<session-management>```의 ```sessoin-fixation-protect``` 속성을 사용하여 동작을 제어할 수 있다. 이 속성은 4가지 옵션을 가지고 있다.

- ```none``` - 아무것도 수행하지 않는다. 원래 세션이 유지된다.
- ```newSession``` - 기존 세션 데이터를 복사하는 것 없이 완전 새로운 세션을 생성한다. (Spring Security 관련 다른 속성은 그대로 복사하여 사용한다.)
- ```migrateSession``` -  새로운 세션을 생성하고 모든 기존 세션 속성을 새로운 세션에 복사한다. 이 설정은 Servlet 3.0 또는 그 이전 버전 컨테이너에서 기본값으로 사용된다.
- ```changeSessionId``` - 새로운 세션을 생성하지 않는다. 그대신, Servlet 컨테이너에서 제공하는 세션 강제고정 공격 방지 기능을 사용한다 (```HttpServletRequest#changeSessionId()```). 이 옵션은 Servlet 3.1(Java EE 7)과 최신 컨테이너에서만 사용할 수 있다. 이전 버전의 컨테이너에서 사용하면 예외가 발생한다. 이는 Servlet 3.1과 그 이후 버전 컨테이너에서 기본값으로 사용된다.

세션 강제고정 공격 방지가 수행되면 어플리케이션 context에 ```SessionFixationProtectionEvent```가 뜬다. 또한 ```changeSessionId```을 사용하는 경우,  ```javax.servlet.http.HttpSessionIdListener```도 이벤트 알림을 받게 된다. 그래서 코드가 두 이벤트를 리스닝하는 경우 주의해야 한다. 자세한 내용은 [21. 세션 관리 (Session Management)](#21-세션-관리-session-management-1)를 참고하면 된다.

<br/>

### 6.3.4. OpenID 지원
네임스페이스는 일반적인 폼 기반 로그인을 대신하거나 아니면 그에 추가해서 간단한 방법으로 OpenID를 지원한다.

```xml
<http>
  <intercept-url pattern="/**" access="ROLE_USER" />
  <openid-login />
</http>
```

먼저 OpenID 공급자(예: myopenid.com)에 사용등록을 하고 인 메모리(in-memory) ```<user-service>```에 사용자 정보를 추가한다.

```xml
<user name="http://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" />
```

인증을 위해 ```myopenid.com``` 사이트를 사용하여 로그인할 수 있어야 한다. 또한 ```openid-login```요소에 ```user-service-ref``` 속성을 설정하여 OpenID를 사용하기 위해 특정 ```UserDetailsService``` bean을 선택할 수도 있다. 자세한 내용은 [인증 공급자](#625-다른-인증-공급자-사용하기)에 대한 이전 절을 참고하면 된다. 상기 사용자 설정에서 password 속성을 생략한 것을 주의해서 기억하자. 무작위 비밀번호를 내부적으로 생성하여 설정의 다른 부분에서 실수로 인증 출처로서 이 사용자 데이터가 사용되지 않게 한다.

### 속성 교환
OpenID [속성 교환](https://openid.net/specs/openid-attribute-exchange-1_0.html)을 지원한다. 예를 들어, 아래 설정은 어플리케이션에서 사용할 수 있도록 OpenID 공급자로부터 이메일 또는 전체 사용자명을 검색하려고 시도하는 예제이다.

```xml
<openid-login>
  <attribute-exchange>
  	<openid-attribute name="email" type="http://axschema.org/contact/email" required="true"/>
  	<openid-attribute name="name" type="http://axschema.org/namePerson"/>
  </attribute-exchange>
</openid-login>
```

각 OpenID 속성의 "type"은 특정 스키마(예: [http://axschema.org/](http://axschema.org/))에 의해 결정되는 URI이다. 성공적인 인증을 위해 속성을 검색해야 하는 경우 ```required```(필수) 속성을 설정할 수 있다. 지원되는 정확한 스키마와 속성은 OpenID 공급자에 따라 다르다. 속성 값은 인증 프로세스의 일부로 반환되고 그 후 아래 코드를 사용하여 접근이 가능하다.

```java
OpenIDAuthenticationToken token = (OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List<OpenIDAttribute> attributes = token.getAttributes();
```

```OpenIDAttribute```에는 속성 유형 및 검색된 값(단일값 또는 여러개의 값)을 포함한다. [9.2. 핵심 요소](#92-핵심-요소)에서 핵심적인 Spring Security 구성요소를 살펴보면서 ```SecurityContextHolder```클래스를 어떻게 사용하는지에 대해 더 자세하게 살펴볼 수 있다. 여러 개의 ID 공급자를 사용하려는 경우 여러 개의 속성 교환 설정 또한 지원된다. 각 속성에 대해 ```identifier-matcher``` 속성을 사용하여 여러 개의 ```attribute-exchange``` 요소를 제공할 수 있다. 여기에는 사용자가 제공한 OpenID 식별자와 일치하는 정규표현식도 포함된다. Google, Yahoo, MyOpenID 공급자에 대한 서로 다른 속성 목록을 제공하려면 OpenID 샘플 어플리케이션을 참고하면 된다.

<br/>

### 6.3.5. 응답 헤더
header 요소를 커스터마이징 하는 방법에 대한 추가적인 내용은 [20. Security HTTP 응답헤더](#20-security-http-응답헤더-1)를 참고하면 된다.

<br/>

### 6.3.6. 나만의 Filter 추가하기
Spring Security를 사용중이라면 프레임워크가 서비스를 적용하기 위해서 필터 체인을 유지한다는 것을 알 것이다. 특정 위치에서 스택에 자신만의 필터를 추가하거나 현재 네임스페이스 설정 옵션(예를 들어, CAS)이 없는 Spring Security 필터를 사용하길 원할 수 있다. 또는 bean을 명시적으로 사용하므로써 쓸 수 있는 몇 가지 추가 설정 옵션을 이용하여 ```<form-login>``` 요소에 의해 생성된 ```UsernamePasswordAuthenticationFilter```와 같은 표준 네임스페이스 필터의 버전을 커스터마이징해 사용하고 싶을 수도 있다. 필터 체인이 직접 노출되지 않는데 네임스페이스 설정으로 어떻게 이러한 것들을 할 수 있을까?

필터의 순서는 항상 네임스페이스를 사용할 때 엄격하게 적용된다. 어플리케이션 context가 생성될 때, 필터 bean들은 코드를 처리하는 네임스페이스에 의해 정렬된다. 그리고 Spring Security 표준 필터들은 각각 네임스페이스와 잘 알려진 위치에서 별칭을 가진다.

> 이전 버전에서는 필터 인스턴스가 생성된 후 어플리케이션 context의 사후 처리 도중에 정렬이 수행되었다. 버전 3.0+에서는 클래스가 인스턴스하ㅗ되기 전에 bean 메타데이터 레벨에서 정렬이 완료된다. 이는 ```<http>``` 요소를 파싱하는 도중에 전체 필터 목록을 알아야 하므로 스택에 개발자 자신만의 필터를 추가하는 방법과 관련이 있다. 따라서 3.0에서 구문이 약간 변경되었다.

필터를 생성하는 필터, 별칭, 네임스페이스 요소/속성은 표 6.1에 나와 있다. 필터는 필터 체인에서 발생하는 순서대로 나열하였다.

__Table 6.1. Standard Filter Aliases and Ordering__

| Alias                        | Filter Class                                        | Namespace Element or Attribute         |
|------------------------------|-----------------------------------------------------|----------------------------------------|
| CHANNEL_FILTER               | ```ChannelProcessingFilter```                       | ```http/intercept-url@requires-channel```    |
| SECURITY_CONTEXT_FILTER      | ```SecurityContextPersistenceFilter```              | ```http```                                   |
| CONCURRENT_SESSION_FILTER    | ```ConcurrentSessionFilter```                       | ```session-management/concurrency-control``` |
| HEADERS_FILTER               | HeaderWriterFilter                                  | http/headers                           |
| CSRF_FILTER                  | CsrfFilter                                          | http/csrf                              |
| LOGOUT_FILTER                | LogoutFilter                                        | http/logout                            |
| X509_FILTER                  | X509AuthenticationFilter                            | http/x509                              |
| PRE_AUTH_FILTER              | AbstractPreAuthenticatedProcessingFilter Subclasses | N/A                                    |
| CAS_FILTER                   | CasAuthenticationFilter                             | N/A                                    |
| FORM_LOGIN_FILTER            | UsernamePasswordAuthenticationFilter                | http/form-login                        |
| BASIC_AUTH_FILTER            | BasicAuthenticationFilter                           | http/http-basic                        |
| SERVLET_API_SUPPORT_FILTER   | SecurityContextHolderAwareRequestFilter             | http/@servlet-api-provision            |
| JAAS_API_SUPPORT_FILTER      | JaasApiIntegrationFilter                            | http/@jaas-api-provision               |
| REMEMBER_ME_FILTER           | RememberMeAuthenticationFilter                      | http/remember-me                       |
| ANONYMOUS_FILTER             | AnonymousAuthenticationFilter                       | http/anonymous                         |
| SESSION_MANAGEMENT_FILTER    | SessionManagementFilter                             | session-management                     |
| EXCEPTION_TRANSLATION_FILTER | ExceptionTranslationFilter                          | http                                   |
| FILTER_SECURITY_INTERCEPTOR  | FilterSecurityInterceptor                           | http                                   |
| SWITCH_USER_FILTER           | SwitchUserFilter                                    | N/A                                    |

<br/>

커스터마이징한 필터 요소와 필터가 표시되어야 하는 위치를 지정하는 이름 중 하나를 사용하여 스택에 자신만의 필터를 추가할 수 있다.

```xml
<http>
  <custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" />
</http>

<beans:bean id="myFilter" class="com.mycompany.MySpecialAuthenticationFilter"/>
```

스택에서 다른 필터 앞이나 뒤에 자신만의 필터를 삽입하려면 ```after``` 또는 ```before``` 속성을 사용할 수도 있다. "FIRST"와 "LAST" 이름은 ```position``` 속성과 함께 사용되어 전체 스택 전과 후에 표시됨을 나타낼 수 있다.

> 네임스페이스에 의해 생성된 표준 필터 중 하나와 동일한 위치를 차지할 수 있는 커스터마이징 필터를 추가하려면 네임스페이스의 버전을 포함하지 말아야 한다. 그리고 표준필터를 생성하는 요소는 제거해야 한다. ```<http>``` 요소 자체를 사용하여 만든 필터(```SecurityContextPersistenceFilter```, ```ExceptionTranslationFilter```, ```FilterSecurityInterceptor```)는 커스터마이징 필터로 대체할 수 없다. 나머지 몇 가지 필터가 기본적으로 추가되지만 비활성화 할 수 있다. 기본적으로 ```AnonymousAuthenticationFilter```가 추가되며 세션 고정 방어가 비활성화 되어 있지 않으면 ```SessionManagementFilter```가 필터 체인에 추가된다.

인증 엔트리 포인트(즉, 인증되지 않은 사용자가 보안설정된 리소스에 접근하려고 시도하여 인증 프로세스가 실행되는 위치)가 필요한 네임스페이스 필터를 대체하려면 커스터마이징한 엔트리 포인트 bean도 추가해야 한다.

### 커스터마이징한 AuthenticationEntryPoint 설정하기
네임스페이스를 통해 폼 로그인, OpenID 또는 기본 인증을 사용하지 않는 경우, 기존 bean 구문을 사용하여 인증필터와 엔트리 포인트를 정의하고 방금 확인한 것처럼 그것들을 네임스페이스에 연결할 수 있다. 해당 ```AuthenticationEntryPoint```는 ```<http>``` 요소의 ```entry-point-ref``` 속성을 사용하여 설정할 수 있다.

CAS 샘플 어플리케이션은 이 구문을 포하하여 네임스페이스와 함께 커스터마이징 bean을 사용하는 좋은 예이다. 인증 엔트리 포인트에 익숙하지 않다면 [9.4.2. AuthenticationEntryPoint](#942-authenticationentrypoint)을 참고하는 것이 좋다.

<br/><br/><br/>

### 6.4. 메서드 Security
버전 2.0부터 Spring Security는 서비스 계층 메소드에 보안을 추가해왔다. 프레임워크의 ```@Secured``` 어노테이션뿐만 아니라 JSR-250 어노테이션 보안도 지원한다. 3.0부터 새로운 [표현식 기반 어노테이션](#26-표현식-기반-접근-제어-1)을 사용할 수도 있게 되었다. ```intercept-methods``` 요소를 사용하여 하나의 bean에 보안을 적용할 수 있다. 또한 AspectJ 스타일 pointcut을 사용하여 서전체 서비스 전반에 걸쳐 여러 개의 bean에도 보안을 적용할 수 있다.

<br/>

### 6.4.1. ```<global-method-security>``` 요소
이 요소는 (요소에 적절한 속성을 사용하여) 어플리케이션에 어노테이션 기반 보안을 활성화하고 전체 어플리케이션 context에 적용될 보안 pointcut 선언을 그룹화하는데 사용된다. 하나의 ```<global-method-security>``` 요소만 선언해야 한다. 아래 선언은 Spring Security의 ```@Secured```에 대한 지원을 활성화시키는 것이다.

```xml
<global-method-security secured-annotations="enabled" />
```

(클래스 또는 인터페이스에 있는) 메소드에 어노테이션을 추가하면 그에 따라 해당 메소드에 대한 접근이 제한된다. Spring Security의 자체 어노테이션은 메소드에 대한 속성 세트를 정의한다. 실제 결정이 필요할 때 이러한 속성세트는 ```AccessDecisionManager```에 전달된다.

```java
public interface BankService {

  @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
  public Account readAccount(Long id);

  @Secured("IS_AUTHENTICATED_ANONYMOUSLY")
  public Account[] findAccounts();

  @Secured("ROLE_TELLER")
  public Account post(Account account, double amount);
}
```

JSR-250 어노테이션에대한 지원은 아래와 같이 활성화할 수 있다.

```xml
<global-method-security jsr250-annotations="enabled" />
```

이러한 것들은 표준 기반이고 간단한 권한 기반 제약사항들이 적용되는 것을 허용한다. 하지만 강력한 Spring Security의 자체 어노테이션을 사용하지 않는다. 새로운 표현식 기반 구문을 사용하려면 아래와 같이 설정하면 된다.

```xml
<global-method-security pre-post-annotations="enabled" />
```

상기 코드와 동일한 Java 코드는 아래와 같다.

```java
public interface BankService {
  @PreAuthorize("isAnonymous()")
  public Account readAccount(Long id);

  @PreAuthorize("isAnonymous()")
  public Account[] findAccounts();

  @PreAuthorize("hasAuthority('ROLE_TELLER')")
  public Account post(Account account, double amount);
}
```

사용자 권한 목록에서 권한명을 확인하는 것 이상의 간단한 규칙을 정의해야 하는 경우 표현식 기반 어노테이션은 아주 적합한 선택이다.

> 어노테이션이 붙은 메서드는 오직 Spring bean으로 정의된 인스턴스에 대해서만 보안 설정이 되어 있다. (여기에서 Spring bean은 메서드 보안이 활성화되어있는 어플리케이션 context에 정의되어 있는 bean을 말한다). new 연산자를 사용하면서 Spring에 의해 생성되지 않은 인스턴스가 보호되기를 원한다면 AspectJ를 사용해야 한다.

> 한 어플리케이션에서 한 개 이상의 어노테이션 유형을 사용할 수 있지만 동작이 잘 정의되지 않기 때문에 인터페이스나 클래스에 대해서는 하나의 유형만 사용해야 한다. 특정 메소드에 적용되는 어노테이션이 두 개면 그 중 하나만 적용된다.


### protect-pointcut을 사용하여 Security pointcut 추가하기
```protect-pointcut```은 특히 간단한 선언만으로 많은 bean에 보안을 적용할 수 있기 때문에 강력하다. 아래 예제를 보자.

```xml
<global-method-security>
  <protect-pointcut expression="execution(* com.mycompany.*Service.*(..))" access="ROLE_USER"/>
</global-method-security>
```

이렇게 하면 클래스가 ```com.mycompany``` 패키지에 있고 클래스 이름이 "Service"로 끝나며 어플리케이션 context에 선언되어 있는 bean의 모든 메서드에 보안이 설정된다. ```ROLE_USER``` 권한을 가진 사용자만이 메서드를 호출할 수 있다. URL 매칭처럼 첫 번째 매칭 표현식이 사용되므로 가장 상세한 매칭 표현식은 pointcut에서 맨 앞에 명시에 주어야 한다. Security 어노테이션은 pointcut보다 우선순위가 높다.

<br/><br/><br/>

### 6.5. 기본 AccessDecisionManager
이 섹션에서는 Spring Security 내 접근 제어를 위한 기본 아키텍처에 대해 어느 정도 알고 있다는 가정하에 쓰여졌다. 단순한 권한 기반 보안 그 이상을 사용하기 위해 일부 커스터마이징 작업을 수행해야 하는 사람들에게만 관련 있는 내용이므로 건너뛰고 나중에 다시 보아도 된다.

네임스페이스 설정을 사용하면 ```AccessDecisionManager```의 기본 인스턴스가 자동적으로 등록된다. 그리고 ```intercept-url``` 및 ```protect-pointcut``` 선언에 지정하는 ```access``` 속성을 기반으로 메서드 호출과 웹 URL 접근에 사용된다(어노테이션 보안 메소드를 사용하는 경우 어노테이션 내의 access 속성도 포함)

기본 전략은 ```RoleVoter```, ```AuthenticatedVoter```과 함께 ```AffirmativeBased``` ```AccessDecisionManager```를 사용하는 것이다. 이 부분에 대한 자세한 내용은 [승인에 관한 장](#24-승인-아키텍처authorization-architecture-1)을 참고하면 된다.

<br/>

### 6.5.1. AccessDecisionManager 커스터마이징하기
보다 복잡한 접근 제어 전략을 사용해야 하는 경우 메소드 보안과 웹 보안에 대한 대안을 쉽게 설정할 수 있다.

메소드 보안의 경우 ```global-method-security```의 ```access-decision-manager-ref``` 속성을 어플리케이션 context의 적절한 ```AccessDecisionManager``` bean ID로 설정하면 된다.

```xml
<global-method-security access-decision-manager-ref="myAccessDecisionManagerBean">
  ...
</global-method-security>
```

웹 보안의 경우에 구문은 동일하지만 ```http``` 요소에 ```access-decision-manager-ref``` 속성을 설정해주면 된다.

```xml
<http access-decision-manager-ref="myAccessDecisionManagerBean">
  ...
</http>
```

<br/><br/><br/>

### 6.6. 인증 관리자(Authentication Manager)와 네임스페이스
Spring Security에서 인증서비스를 제공하는 메인 인터페이스는 ```AuthenticationManager```이다. 이는 Spring Security의 ```ProviderManager``` 클래스의 인스턴스이다. 이전에 프레임워크를 사용했다면 이미 익숙할 것이다. 그렇지 않은 경우 추후 [9.3. 인증 (Authentication)](#93-인증-authentication)에서 다루니 참고하면 된다. bean 인스턴스는 ```authentication-manager``` 네임스페이스 요소를 사용하여 등록하면 된다. 네임스페이스를 통해 HTTP 또는 메서드 보안을 사용하는 경우 커스터마이징한 ```AuthenticationManager```를 사용할 수 없지만 사용하는 ```AuthenticationProvider```를 완전히 제어할 수 있기 때문에 문제가 되지 않는다.

```ProviderManager```에 ```AuthenticationProvider``` bean을 등록할 수 있으며 ```ref``` 속성과 ```<authentication-provider>``` 요소를 함께 사용하여 이 작업을 할 수 있다. 여기서 속성 값은 추가하려는 provider bean 이름이다. 예를 들자면 아래와 같다.

```xml
<authentication-manager>
  <authentication-provider ref="casAuthenticationProvider"/>
</authentication-manager>

<bean id="casAuthenticationProvider" class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
  ...
</bean>
```

또 하나의 공통적인 요구사항은 context의 다른 bean이 ```AuthenticationManager```에 대한 참조를 요구할 수 있다는 것이다. ```AuthenticationManager```의 별칭을 쉽게 등록할 수 있으며 어플리케이션 context의 다른 위치에서 이름을 사용할 수 있다.

```xml
<security:authentication-manager alias="authenticationManager">
  ...
</security:authentication-manager>

<bean id="customizedFormLoginFilter" class="com.somecompany.security.web.CustomFormLoginFilter">
  <property name="authenticationManager" ref="authenticationManager"/>
  ...
</bean>
```

<sub id="footnote_r_1">[[1]](#footkey_r_1)</sub> <sub>[29. LDAP 인증 (LDAP Authentication)](#29-ldap-인증-ldap-authentication-1)에서 ```ldap-server``` 요소 사용에 대한 자세한 내용을 볼 수 있다.</sub>

<sub id="footnote_r_2">[[2]](#footkey_r_2)</sub> <sub>실제로 매칭이 어떻게 동작하는지 자세히 알고 싶다면 [13.4. 요청 매칭(Request Matching)과 HttpFirewall](#134-요청-매칭request-matching과-httpfirewall) 섹션을 참고하면 된다.</sub>

<sub id="footnote_r_3">[[3]](#footkey_r_3)</sub> <sub>[22. 익명 인증(Anonymous Authentication)](#22-익명-인증anonymous-authentication-1)을 참고하는 것이 좋다.</sub>

<sub id="footnote_r_4">[[4]](#footkey_r_4)</sub> <sub>다중 ```<http>``` 요소를 사용하는 것은 중요한 기능이다. 예를 들어, 네임스페이스가 동일한 어플리케이션 내에서 stateful 경로와 stateless 경로를 동시에 지원할 수 있다. ```intercept-url``` 요소에서 ```filter="none"```속성을 사용하는 이전 구문은 이러한 변화와 호환되지 않으며 3.1에서는 더 이상 지원되지 않는다.</sub>

<sub id="footnote_r_5">[[5]](#footkey_r_5)</sub> <sub>채널 처리(channel-processing)의 구현을 어떻게 하는지에 대한 자세한 내용은 Javadoc의 ```ChannelProcessingFilter``` 및 관련 클래스 부분을 살펴보는 것이 좋다.</sub>

<br/><br/><br/><br/>

## 7. 어플리케이션 샘플
프로젝트와 함께 사용할 수 있는 몇 가지 샘플 어플리케이션이 있다. 지나치게 큰 양의 다운로드를 피하기 위해 "tutorial(기본)", "contacts(고급)" 샘플만 Spring Security 배포 zip파일에 포함되어 있다. 다른 샘플 어플리케이션들은 [소개](#244-소스-checkout-하기)에서 설명한대로 직접 빌드할 수 있으니 그렇게 하면 된다. 직접 프로젝트를 빌드하는 것은 쉽다. 그리고 [http://spring.io/spring-security/](http://spring.io/spring-security/)에 있는 프로젝트 웹 사이트에 자세한 정보가 있으니 참고하면 된다. 이 장에서 언급되는 모든 경로는 프로젝트 소스 디렉토리에 대한 상대경로를 표시한 것이니 참고하자.

<br/><br/>

### 7.1. Tutorial 샘플 (기본)
Tutorial 샘플은 처음 시작할 때 사용하기 좋은 기본 예제이다. 전반적으로 간단한 네임스페이스 설정을 사용한다. 컴파일 된 어플리케이션이 배포 zip파일에 포함되어 있으며, 웹 컨테이너에 배포될 수 있게 준비되어 있다(```spring-security-samples-tutorial-3.1.x.war```). [폼 기반](#623-form과-기본적인-로그인-옵션) 인증 메커니즘은 일반적으로 사용되는 [remember-me](#17-remember-me-인증authentication-1) 인증 공급자와 함께 사용되고 자동으로 쿠키를 사용하여 로그인정보를 기억한다.

tutorial 샘플부터 시작하는 것을 추천한다. XML은 최소한의 설정만 있으며 따라하기 쉽다. 가장 중요한 것은 하나의 XML 파일(및 해당 ```web.xml``` 항목)을 기존 어플리케이션에 쉽게 추가할 수 있다는 것이다. 이러한 기본적인 통합을 할 경우에만 메서드 승인 또는 도메인 객체 보안을 추가하는 것이 좋다.

<br/>

### 7.2. Contacts 샘플 (고급)
Contacts 샘플은 기본 어플리케이션 보안 기능 뿐만 아니라 도메인 객체 접근 제어 목록(ACLs)의 더욱 강력한 기능을 보여주는 고급 예제이다. 주어진 어플리케이션에서는 사용자가 간단한 연락처(도메인 객체) 데이터베이스를 관리할 수 있는 인터페이스를 제공한다.

배포하기 위해서는 컨테이너의 ```webapps``` 디렉토리에 Spring Security WAR 파일을 복사해 넣으면 된다. war는 ```spring-security-samples-contacts-3.1.x.war```이다(뒤쪽에 붙인 버전 번호는 사용중인 릴리즈에 따라 바꾸어 생각하면 된다).

컨테이너를 시작한 후 어플리케이션을 로드할 수 있는지 확인한다. [http://localhost:8080/contacts](http://localhost:8080/contacts) (또는 웹컨테이너 및 배포한 WAR 파일에 적합한 URL)을 접속한다.

그런 다음, "Debug"를 클릭한다. 인증하라는 메시지가 표시되며, 해당 페이지에 일련의 사용자명과 비밀번호가 표시된다. 이 중 하나를 사용하여 인증하고 결과 페이지를 보자. 아래와 유사한 성공 메시지가 표시된다.

```
Security Debug Information

Authentication object is of type:
org.springframework.security.authentication.UsernamePasswordAuthenticationToken

Authentication object as a String:

org.springframework.security.authentication.UsernamePasswordAuthenticationToken@1f127853:
Principal: org.springframework.security.core.userdetails.User@b07ed00: Username: rod; \
Password: [PROTECTED]; Enabled: true; AccountNonExpired: true;
credentialsNonExpired: true; AccountNonLocked: true; \
Granted Authorities: ROLE_SUPERVISOR, ROLE_USER; \
Password: [PROTECTED]; Authenticated: true; \
Details: org.springframework.security.web.authentication.WebAuthenticationDetails@0: \
RemoteIpAddress: 127.0.0.1; SessionId: 8fkp8t83ohar; \
Granted Authorities: ROLE_SUPERVISOR, ROLE_USER

Authentication object holds the following granted authorities:

ROLE_SUPERVISOR (getAuthority(): ROLE_SUPERVISOR)
ROLE_USER (getAuthority(): ROLE_USER)

Success! Your web filters appear to be properly configured!
```

상기 메시지가 성공적으로 수신되면 샘플 어플리케이션의 홈페이지로 돌아가서 "Manage"를 클릭한다. 그러면 어플리케이션을 사용할 수 있게 된다. 현재 로그인한 사용자의 연락처만 표시되고 ```ROLE_SUPERVISOR``` 권한을 가진 사용자만 연락처를 삭제할 수 있는 접근 권한이 부여된다. 한편, 뒤에서는 ```MethodSecurityInterceptor```가 비즈니스 객체를 보호한다.

어플리케이션에서 다른 연락처와 관련된 접근 제어 목록을 수정할 수도 있다. 어플리케이션 context XML을 검토하여 어떻게 작동하는지 이해하고 시도해보자.

<br/>

### 7.3. LDAP 샘플
LDAP 샘플 어플리케이션은 기본 설정을 제공하고, 동일한 어플리케이션 context file내에서 네임스페이스 설정과 bean을 사용한 설정 모두 가능하다. 즉, 이 어플리케이션에는 실제로 두 개의 동일한 인증 공급자가 설정되어 있는 것이다.

<br/>

### 7.4. OpenId 샘플
OpenID 샘플은 OpenID를 설정을 위해 네임스페이스를 사용하는 방법과 Google, Yahoo, MyOpenID와 같은 ID 공급자에 대한 [속성 교체](https://openid.net/specs/openid-attribute-exchange-1_0.html) 설정방법을 보여준다(원한다면 다른 공급자를 추가하여 실험해 볼 수도 있음). JQuery 기반 openid-selector 프로젝트를 사용하여 사용자 친화적인 로그인 페이지를 제공하기 때문에 사용자가 OpenID 식별자를 전부 입력하는 대신 공급자를 쉽게 선택할 수 있다.

이 어플리케이션은 어떤 사용자든 (OpenID 인증이 성공한 경우) 사이트에 접근할 수 있다는 점에서 일반적인 인증 시나리오와 다르다. 처음 로그인할 경우 "Welcome [OOO님]"이라는 메시지가 나타난다. 로그아웃하고 동일한 OpenID ID로 다시 로그인하면 "Welcom Back"으로 변경된다. 이는 모든 사용자에게 표준 권한을 부여하고 ID를 내부적으로 map에 저장하는 커스터마이징한 ```UserDetailService```를 사용하여 수행된다. 분명히 실제 어플리케이션은 데이터베이스를 사용하여 ID를 저장할 것이다. 더 자세한 정보는 소스를 보면 된다. 또한 이 클래스는 다른 공급자로부터 다른 속성이 반환되는 일도 고려해, 거기에 따라 사용자를 설명하는 이름을 빌드한다.

<br/>

### 7.5. CAS 샘플
CAS 샘플을 사용하려면 CAS 서버와 CAS 클라이언트를 모두 실행해야 한다. [소개](#244-소스-checkout-하기)에서 설명하였듯이 배포판에는 이 부분이 포함되어 있지 않으므로 프로젝트 코드를 체크아웃하여 확인해야 한다. ```sample/cas``` 디렉토리 하위에서 관련된 파일을 찾을 수 있다. ```Readme.txt``` 파일에는 Source tree에서 직접 서버와 클라이언트를 함께 구동시키는 방법과 SSL 지원을 완료하는 방법이 설명되어 있다.

<br/>

### 7.6. JAAS 샘플
JAAS 샘플은 Spring Security와 함께 JAAS LoginModule을 사용하는 방법을 설명하기에 좋은 간단한 예제이다. 제공되는 LoginModule은 사용자명이 비밀번호와 같으면 사용자를 인증해주고 그렇지 않으면 LoginException을 발생한다. 예제에서 사용된 AuthorityGranter는 항상 ROLE_USER 권한을 부여한다. 또한 샘플 어플리케이션은 [jaas-api-provision](#jaas-api-provision)을 "true"로 설정하여 LoginModule에서 반환되는 JAAS Subject으로 실행하는 방법을 보여주기도 한다.

<br/>

### 7.7. 사전 인증(Pre-Authentication) 샘플
이 샘플 어플리케이션은 Java EE 컨테이너의 로그인 정보를 사용하기 위해 [사전 인증](#28-사전인증pre-authentication-시나리오-1) 프레임워크에서 bean을 연결하는 방법을 보여준다. 사용자명과 권한은 컨테이너에서 설정한 것이다.\

코드는 ```samples/preauth```에 있다.

<br/><br/><br/><br/>

## 8. Spring Security 커뮤니티

### 8.1. 이슈 트래킹
Spring Security는 JIRA를 사용하여 버그 리포트와 개선 요청(enhancement request)을 관리한다. 버그를 발견하면 JIRA를 사용하여 리포트를 로그를 남기면 된다. 서포트 포럼, 메일링 리스트, 또는 프로젝트 개발자에게 이메일보내어 로그를 남기지는 말아야 한다. 이러한 접근 방식은 임시적이며 보다 공식적인 프로세스를 사용하여 버그를 관리하는 것을 선호한다.

가능하면 이슈 리포트에 잘못된 동작을 나타내는 JUnit 테스트를 제공하는 것이 좋다. 또는 더 나은 방법은 문제를 해결한 패치를 제공하는 것이다. 마찬가지로, 개선사항을 이슈 트래커에 로그를 남기는 것도 환영하지만 해당 단위 테스트를 포함하는 경우에만 개선 요청 수락한다. 이는 프로젝트 테스트 커버리지가 적절히 유지되도록 하기 위해 필요하다.

[https://github.com/spring-projects/spring-security/issues](https://github.com/spring-projects/spring-security/issues)에서 이슈 트래커에 접근할 수 있다.

<br/>

### 8.2. 참여하기
Spring Security 프로젝트에
대한 당신의 참여를 환영한다. 포럼을 읽거나 다른 사람들의 질문에 응답하고, 새로운 코드를 작성하고, 기존 코드를 개선하고, 문서 작성을 돕고, 샘플 또는 자습서를 개발하거나, 간단히 제안하는 등 다양한 방법으로 기여할 수 있다.

<br/>

### 8.3. 추가적인 정보
Spring Security에 대한 질문과 의견을 환영한다. Spring at Stack Overflow 웹사이트 [http://spring.io/questions](http://spring.io/questions)를 사용하면 Spring Security를 프레임워크 다른 사용자와 논의할 수 있다. 위에 설명한 버그 리포트는 JIRA를 사용하는 것을 잊지 말아줬으면 좋겠다.

<br/><br/><br/><br/><br/>

# [2] 아키텍처(Architecture)와 구현(Implementation)
네임스페이스 설정 기반 어플리케이션을 설정하고 실행하는 것에 익숙해지면 프레임워크가 실제로 네임스페이스 뒤에서 어떻게 작동하는지 더 잘 이해할 수 있다. 대부분의 소프트웨어처럼 Spring Security는 프레임워크 전반에 걸쳐 일반적으로 사용되는 특정 주요 인터페이스, 클래스, 개념적 추상화를 제공한다. 이 레퍼런스 가이드에서는 이러한 것들의 일부를 살펴보고 그것들이 Spring Security 내에서 인증 및 접근 제어를 지원하기 위해 어떻게 함께 작동하는지 살펴볼 것이다.

<br/>

## 9. 기술 개요
### 9.1. 실행 환경


<br/>

### 9.2. 핵심 요소

<br/>

### 9.2.1. SecurityContextHoler, SecurityContext와 Authentication 객체
### 현재 사용자에 대한 정보 얻기

```java
Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) {
  String username = ((UserDetails)principal).getUsername();
} else {
  String username = principal.toString();
}
```

<br/>

### 9.2.2. UerDetailsService

```java
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
```

>

<br/>

### 9.2.3. GrantedAuthority

<br/>

### 9.2.4. 요약


<br/><br/><br/>

### 9.3. 인증 (Authentication)

<br/>

### 9.3.1. Spring Security에서 인증(Authentication)이란 무엇인가?

```java
import org.springframework.security.authentication.*;
import org.springframework.security.core.*;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

public class AuthenticationExample {
  private static AuthenticationManager am = new SampleAuthenticationManager();

  public static void main(String[] args) throws Exception {
  	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

  	while(true) {
    	System.out.println("Please enter your username:");
    	String name = in.readLine();
    	System.out.println("Please enter your password:");
    	String password = in.readLine();
    	try {
    		Authentication request = new UsernamePasswordAuthenticationToken(name, password);
    		Authentication result = am.authenticate(request);
    		SecurityContextHolder.getContext().setAuthentication(result);
    		break;
    	} catch(AuthenticationException e) {
    		System.out.println("Authentication failed: " + e.getMessage());
    	}
  	}
  	System.out.println("Successfully authenticated. Security context contains: " + SecurityContextHolder.getContext().getAuthentication());
  }
}

class SampleAuthenticationManager implements AuthenticationManager {
  static final List<GrantedAuthority> AUTHORITIES = new ArrayList<GrantedAuthority>();

  static {
  	AUTHORITIES.add(new SimpleGrantedAuthority("ROLE_USER"));
  }

  public Authentication authenticate(Authentication auth) throws AuthenticationException {
  	if (auth.getName().equals(auth.getCredentials())) {
  	   return new UsernamePasswordAuthenticationToken(auth.getName(), auth.getCredentials(), AUTHORITIES);
  	}
  	throw new BadCredentialsException("Bad Credentials");
  }
}
```

```
Please enter your username:
bob
Please enter your password:
password
Authentication failed: Bad Credentials
Please enter your username:
bob
Please enter your password:
bob
Successfully authenticated. Security context contains: \
org.springframework.security.authentication.UsernamePasswordAuthenticationToken@441d0230: \
Principal: bob; Password: [PROTECTED]; \
Authenticated: true; Details: null; \
Granted Authorities: ROLE_USER
```

<br/>

### 9.3.2. SecurityContextHoler 내용 직접 설정하기

<br/><br/><br/>

### 9.4. 웹 어플리케이션에서의 인증(Authentication)

<br/>

### 9.4.1. ExceptionTranslationFilter

<br/>

### 9.4.2. AuthenticationEntryPoint

<br/>

### 9.4.3. 인증 절차

<br/>

### 9.4.4. 요청(request)간의 SecurityContext 저장하기

>

<br/><br/><br/>

### 9.5. Spring Security에서의 접근제어(승인,Authorization)

<br/>

### 9.5.1. Security와 AOP

<br/>

### 9.5.2. 보안객체(Secure Object)와 AbstractSecurityInterceptor

### 설정 속성(Configuration Attributes)

### RunAsManager

### AfterInvocationManager

### 보안객체(Secure Object) 모델 확장하기

<br/><br/><br/>

### 9.6. 언어 설정(Localization)

```xml
<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
  <property name="basename" value="classpath:org/springframework/security/messages"/>
</bean>
```

<br/><br/><br/><br/>

## 10. 핵심 서비스

<br/>

### 10.1. AuthenticationManager, ProviderManager, AuthenticationProvider

```xml
<bean id="authenticationManager"
		class="org.springframework.security.authentication.ProviderManager">
	<constructor-arg>
		<list>
			<ref local="daoAuthenticationProvider"/>
			<ref local="anonymousAuthenticationProvider"/>
			<ref local="ldapAuthenticationProvider"/>
		</list>
	</constructor-arg>
</bean>
```

<br/>

### 10.1.1. 인증 성공 시 자격증명(Credentials) 지우기

<br/>

### 10.1.2. aoAuthenticationProvider

```xml
<bean id="daoAuthenticationProvider" class="org.springframework.security.authentication.dao.DaoAuthenticationProvider">
  <property name="userDetailsService" ref="inMemoryDaoImpl"/>
  <property name="passwordEncoder" ref="passwordEncoder"/>
</bean>
```

<br/><br/><br/>

### 10.2. UserDetailsService 구현

```java
UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
```

<br/>

### 10.2.1. 메모리상 인증(In-Memory Authorization)

```xml
<user-service id="userDetailsService">
  <user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" />
  <user name="bob" password="bobspassword" authorities="ROLE_USER" />
</user-service>
```

```xml
<user-service id="userDetailsService" properties="users.properties"/>
```

```
username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]
```

```
jimi=jimispassword,ROLE_USER,ROLE_ADMIN,enabled
bob=bobspassword,ROLE_USER,enabled
```

<br/>

### 10.2.2. JdbcDaoImpl

```xml
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
  <property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
  <property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
  <property name="username" value="sa"/>
  <property name="password" value=""/>
</bean>

<bean id="userDetailsService" class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl">
  <property name="dataSource" ref="dataSource"/>
</bean>
```

### 권한(Authority) 그룹

<br/><br/><br/>

### 10.3. 비밀번호 암호화

<br/>

### 10.3.1. hash란 무엇인가?

```
5f4dcc3b5aa765d61d8327deb882cf99
```

<br/>

### 10.3.2. hash에 양념 추가하기

>

<br/>

### 10.3.3. Hashing과 인증(Authentication)

<br/><br/><br/>

### 10.4. Jackson 지원

```java
ObjectMapper mapper = new ObjectMapper();
ClassLoader loader = getClass().getClassLoader();
List<Module> modules = SecurityJackson2Modules.getModules(loader);
mapper.registerModules(modules);

// ... use ObjectMapper as normally ...
SecurityContext context = new SecurityContextImpl();
// ...
String json = mapper.writeValueAsString(context);
```

<br/><br/><br/><br/><br/>

# [3] 테스트

>

## 11. 메서드 Security 테스트

```java
public class HelloMessageService implements MessageService {

	@PreAuthorize("authenticated")
	public String getMessage() {
		Authentication authentication = SecurityContextHolder.getContext()
															.getAuthentication();
		return "Hello " + authentication;
	}
}
```

```
Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER
```

<br/>

### 11.1. Security Test 설치

```java
@RunWith(SpringJUnit4ClassRunner.class) 1
@ContextConfiguration 2
public class WithMockUserTests {
```

>

```java
@Test(expected = AuthenticationCredentialsNotFoundException.class)
public void getMessageUnauthenticated() {
	messageService.getMessage();
}
```

<br/>

### 11.2. @WithMockUser

```java
@Test
@WithMockUser
public void getMessageWithMockUser() {
  String message = messageService.getMessage();
  ...
}
```

```java
@Test
@WithMockUser("customUsername")
public void getMessageWithMockUserCustomUsername() {
	String message = messageService.getMessage();
  ...
}
```

```java
@Test
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public void getMessageWithMockUserCustomUser() {
	String message = messageService.getMessage();
	...
}
```

```java
@Test
@WithMockUser(username = "admin", authorities = { "ADMIN", "USER" })
public void getMessageWithMockUserCustomAuthorities() {
	String message = messageService.getMessage();
	...
}
```

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public class WithMockUserTests {
```

<br/>

### 11.3. @WithAnonymousUser

```java
@RunWith(SpringJUnit4ClassRunner.class)
@WithMockUser
public class WithUserClassLevelAuthenticationTests {

	@Test
	public void withMockUser1() {
	}

	@Test
	public void withMockUser2() {
	}

	@Test
	@WithAnonymousUser
	public void anonymous() throws Exception {
		// override default to run as anonymous user
	}
}
```

<br/>

### 11.4. @WithUserDetails

```java
@Test
@WithUserDetails
public void getMessageWithUserDetails() {
	String message = messageService.getMessage();
	...
}
```

```java
@Test
@WithUserDetails("customUsername")
public void getMessageWithUserDetailsCustomUsername() {
	String message = messageService.getMessage();
	...
}
```

```java
@Test
@WithUserDetails(value="customUsername", userDetailsServiceBeanName="myUserDetailsService")
public void getMessageWithUserDetailsServiceBeanName() {
	String message = messageService.getMessage();
	...
}
```

<br/>

### 11.5. @WithSecurityContext

```java
@Retention(RetentionPolicy.RUNTIME)
@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)
public @interface WithMockCustomUser {

	String username() default "rob";

	String name() default "Rob Winch";
}
```

```java
public class WithMockCustomUserSecurityContextFactory
	implements WithSecurityContextFactory<WithMockCustomUser> {
	@Override
	public SecurityContext createSecurityContext(WithMockCustomUser customUser) {
		SecurityContext context = SecurityContextHolder.createEmptyContext();

		CustomUserDetails principal =
			new CustomUserDetails(customUser.name(), customUser.username());
		Authentication auth =
			new UsernamePasswordAuthenticationToken(principal, "password", principal.getAuthorities());
		context.setAuthentication(auth);
		return context;
	}
}
```

```java
final class WithUserDetailsSecurityContextFactory
	implements WithSecurityContextFactory<WithUserDetails> {

	private UserDetailsService userDetailsService;

	@Autowired
	public WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public SecurityContext createSecurityContext(WithUserDetails withUser) {
		String username = withUser.value();
		Assert.hasLength(username, "value() must be non-empty String");
		UserDetails principal = userDetailsService.loadUserByUsername(username);
		Authentication authentication = new UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());
		SecurityContext context = SecurityContextHolder.createEmptyContext();
		context.setAuthentication(authentication);
		return context;
	}
}
```

<br/>

### 11.6. 메타 어노테이션(meta annotation) 테스트하기

```java
@WithMockUser(username="admin",roles={"USER","ADMIN"})
```

<br/><br/><br/><br/>

## 12. Spring MVC 테스트

### 12.1. MockMvc와 Spring Security 설치하기

>

```java
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WebAppConfiguration
public class CsrfShowcaseTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setup() {
		mvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity()) 1
				.build();
	}

...
```

<br/><br/><br/>

### 12.2. SecurityMockMvcRequestPostProcessors

```java
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;
```

<br/>

### 12.2.1. CSRF 방어 테스트

```java
mvc
	.perform(post("/").with(csrf()))
```

```java
mvc
	.perform(post("/").with(csrf().asHeader()))
```

```java
mvc
	.perform(post("/").with(csrf().useInvalidToken()))
```

<br/>

### 12.2.2. Spring MVC 테스트에서 사용자로서 테스트 수행하기

<br/>

### 12.2.3. RequestPostProcessor를 사용한 Spring MVC 테스트에서 사용자로서 테스트 수행하기

>

```java
mvc
	.perform(get("/").with(user("user")))
```

```java
mvc
	.perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))
```

```java
mvc
	.perform(get("/").with(user(userDetails)))
```

```java
mvc
	.perform(get("/").with(anonymous()))
```

```java
mvc
	.perform(get("/").with(authentication(authentication)))
```

```java
mvc
	.perform(get("/").with(securityContext(securityContext)))
```

```java
mvc = MockMvcBuilders
		.webAppContextSetup(context)
		.defaultRequest(get("/").with(user("user").roles("ADMIN")))
		.apply(springSecurity())
		.build();
```

```java
public static RequestPostProcessor rob() {
	return user("rob").roles("ADMIN");
}
```

```java
import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

...

mvc
	.perform(get("/").with(rob()))
```


### 어노테이션을 사용한 Spring MVC 테스트에서 사용자로서 테스트 수행하기

```java
@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
```

```java
@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
		.perform(get("/"))
		...
}
```

<br/>

### 12.2.4. HTTP 기본 인증 테스트하기

```java
mvc
	.perform(get("/").with(httpBasic("user","password")))
```

```
Authorization: Basic dXNlcjpwYXNzd29yZA==
```

<br/><br/><br/>

### 12.3. SecurityMockMvcRequestBuilders

```java
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;
```

<br/>

### 12.3.1. Form 기반 인증 테스트하기

```java
mvc
	.perform(formLogin())
```

```java
mvc
	.perform(formLogin("/auth").user("admin").password("pass"))
```

```java
mvc
	.perform(formLogin("/auth").user("u","admin").password("p","pass"))
```

<br/>

### 12.3.2. 로그아웃 테스트하기

```java
mvc
	.perform(logout())
```

```java
mvc
	.perform(logout("/signout"))
```

<br/><br/><br/>

### 12.4. SecurityMockMvcResultMatchers

```java
import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;
```

<br/>

### 12.4.1. 비인증 테스트 (Unauthenticated Assertion)

```java
mvc
	.perform(formLogin().password("invalid"))
	.andExpect(unauthenticated());
```

<br/>

### 12.4.2. 인증 테스트 (Authenticated Assertion)

```java
mvc
	.perform(formLogin())
	.andExpect(authenticated());
```

```java
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withRoles("USER","ADMIN"));
```

```java
mvc
	.perform(formLogin().user("admin"))
	.andExpect(authenticated().withUsername("admin"));
```

```java
mvc
	.perform(formLogin().user("admin").roles("USER","ADMIN"))
	.andExpect(authenticated().withUsername("admin"));
```

<br/><br/><br/><br/><br/>

# [4] 웹 어플리케이션 Security

<br/>

## 13. Security Filter Chain

<br/>

### 13.1. DelegatingFilterProxy

```xml
<filter>
  <filter-name>myFilter</filter-name>
  <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>

<filter-mapping>
  <filter-name>myFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

<br/>

### 13.2. FilterChainProxy

```xml
<bean id="filterChainProxy" class="org.springframework.security.web.FilterChainProxy">
<constructor-arg>
	<list>
	<sec:filter-chain pattern="/restful/**" filters="
		securityContextPersistenceFilterWithASCFalse,
		basicAuthenticationFilter,
		exceptionTranslationFilter,
		filterSecurityInterceptor" />
	<sec:filter-chain pattern="/**" filters="
		securityContextPersistenceFilterWithASCTrue,
		formLoginFilter,
		exceptionTranslationFilter,
		filterSecurityInterceptor" />
	</list>
</constructor-arg>
</bean>
```

<br/>

### 13.2.1. Filter Chain 우회하기

<br/><br/><br/>

### 13.3. Filter 순서

<br/><br/>

### 13.4. 요청 매칭(Request Matching)과 HttpFirewall

<br/><br/>

### 13.5. 다른 Filter 기반 프레임워크 함께 사용하기

<br/><br/>

### 13.6. 고급 네임스페이스 설정

```xml
<!-- Stateless RESTful service using Basic authentication -->
<http pattern="/restful/**" create-session="stateless">
  <intercept-url pattern='/**' access="hasRole('REMOTE')" />
  <http-basic />
</http>

<!-- Empty filter chain for the login page -->
<http pattern="/login.htm*" security="none"/>

<!-- Additional filter chain for normal users, matching all other requests -->
<http>
  <intercept-url pattern='/**' access="hasRole('USER')" />
  <form-login login-page='/login.htm' default-target-url="/home.htm"/>
  <logout />
</http>
```

<br/><br/><br/><br/>

## 14. 핵심 Security Filter

<br/>

### 14.1. FilterSecurityInterceptor

```xml
<bean id="filterSecurityInterceptor" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
  <property name="authenticationManager" ref="authenticationManager"/>
  <property name="accessDecisionManager" ref="accessDecisionManager"/>
  <property name="securityMetadataSource">
  	<security:filter-security-metadata-source>
  	<security:intercept-url pattern="/secure/super/**" access="ROLE_WE_DONT_HAVE"/>
  	<security:intercept-url pattern="/secure/**" access="ROLE_SUPERVISOR,ROLE_TELLER"/>
  	</security:filter-security-metadata-source>
  </property>
</bean>
```

```xml
<bean id="filterInvocationInterceptor" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
  <property name="authenticationManager" ref="authenticationManager"/>
  <property name="accessDecisionManager" ref="accessDecisionManager"/>
  <property name="runAsManager" ref="runAsManager"/>
  <property name="securityMetadataSource">
  	<security:filter-security-metadata-source request-matcher="regex">
  	<security:intercept-url pattern="\A/secure/super/.*\Z" access="ROLE_WE_DONT_HAVE"/>
  	<security:intercept-url pattern="\A/secure/.*\" access="ROLE_SUPERVISOR,ROLE_TELLER"/>
  	</security:filter-security-metadata-source>
  </property>
</bean>
```

<br/><br/>

### 14.2. ExceptionTranslationFilter

```xml
<bean id="exceptionTranslationFilter" class="org.springframework.security.web.access.ExceptionTranslationFilter">
  <property name="authenticationEntryPoint" ref="authenticationEntryPoint"/>
  <property name="accessDeniedHandler" ref="accessDeniedHandler"/>
</bean>

<bean id="authenticationEntryPoint" class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
  <property name="loginFormUrl" value="/login.jsp"/>
</bean>

<bean id="accessDeniedHandler" class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
  <property name="errorPage" value="/accessDenied.htm"/>
</bean>
```

<br/>

### 14.2.1. AuthenticationEntryPoint

<br/>

### 14.2.2. AccessDeniedHandler

<br/>

### 14.2.3. Saved Request와 RequestCache 인터페이스

<br/><br/><br/>

### 14.3. SecurityContextPersistenceFilter

```xml
<bean id="securityContextPersistenceFilter" class="org.springframework.security.web.context.SecurityContextPersistenceFilter"/>
```

<br/>

### 14.3.1. SecurityContextPrepository

```java
public interface SecurityContextRepository {

  SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder);

  void saveContext(SecurityContext context, HttpServletRequest request, HttpServletResponse response);
}
```

```xml
<bean id="securityContextPersistenceFilter" class="org.springframework.security.web.context.SecurityContextPersistenceFilter">
  <property name='securityContextRepository'>
  	<bean class='org.springframework.security.web.context.HttpSessionSecurityContextRepository'>
  	<property name='allowSessionCreation' value='false' />
  	</bean>
  </property>
</bean>
```

<br/><br/><br/>

### 14.4. UsernamePasswordAuthenticationFilter

```xml
<bean id="authenticationFilter" class= "org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter">
  <property name="authenticationManager" ref="authenticationManager"/>
</bean>
```

<br/>

### 14.4.1. 인증 성공/실패 시 어플리케이션의 흐름

>

<br/><br/><br/><br/>

## 15. Servlet API 통합

<br/>

### 15.1. Servlet 2.5+ 통합

### 15.1.1. HttpServletRequest.getRemoteUser()

<br/>

### 15.1.2. HttpServletRequest.getUserPrincipal()

```java
Authentication auth = httpServletRequest.getUserPrincipal();
// assume integrated custom UserDetails called MyCustomUserDetails
// by default, typically instance of UserDetails
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();
```

>

<br/>

### 15.1.3. HttpServletRequest.isUserInRole(String)

```java
boolean isAdmin = httpServletRequest.isUserInRole("ADMIN");
```

<br/><br/><br/>

### 15.2. Servlet 3+ 통합

### 15.2.1. HttpServletRequest.authenticate(HttpServletRequest, HttpServletResponse)

<br/>

### 15.2.2. HttpServletRequest.login(String, String)

```java
try {
  httpServletRequest.login("user","password");
} catch(ServletException e) {
  // fail to authenticate
}
```

>

<br/>

### 15.2.3. HttpServletRequest.logout()

<br/>

### 15.2.4. AsyncContext.start(Runnable)

```java
final AsyncContext async = httpServletRequest.startAsync();
async.start(new Runnable() {
	public void run() {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		try {
			final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
			asyncResponse.setStatus(HttpServletResponse.SC_OK);
			asyncResponse.getWriter().write(String.valueOf(authentication));
			async.complete();
		} catch(Exception e) {
			throw new RuntimeException(e);
		}
	}
});
```

<br/>

### 15.2.5. 비동기 Servlet 지원

```xml
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0">

</web-app>
```

```
<filter>
  <filter-name>springSecurityFilterChain</filter-name>
  <filter-class>
  	org.springframework.web.filter.DelegatingFilterProxy
  </filter-class>
  <async-supported>true</async-supported>
</filter>
<filter-mapping>
  <filter-name>springSecurityFilterChain</filter-name>
  <url-pattern>/*</url-pattern>
  <dispatcher>REQUEST</dispatcher>
  <dispatcher>ASYNC</dispatcher>
</filter-mapping>
```

```java
httpServletRequest.startAsync();
new Thread("AsyncThread") {
	@Override
	public void run() {
		try {
			// Do work
			TimeUnit.SECONDS.sleep(1);

			// Write to and commit the httpServletResponse
			httpServletResponse.getOutputStream().flush();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}.start();
```

<br/><br/><br/>

### 15.3. Servlet 3.1+ 통합

### 15.3.1. HttpServletRequest.changeSessionId()

<br/><br/><br/><br/>

## 16. 기본 인증(Basic Authorization)과 다이제스트 인증(Digest Authorization)

<br/>

### 16.1. BasicAuthenticationFilter

<br/>

### 16.1.1. 설정

```xml
<bean id="basicAuthenticationFilter" class="org.springframework.security.web.authentication.www.BasicAuthenticationFilter">
  <property name="authenticationManager" ref="authenticationManager"/>
  <property name="authenticationEntryPoint" ref="authenticationEntryPoint"/>
</bean>

<bean id="authenticationEntryPoint" class="org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint">
  <property name="realmName" value="Name Of Your Realm"/>
</bean>
```

<br/><br/><br/>

### 16.2. DigestAuthorizationFilter

```
base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token
```

<br/>

### 16.2.1. 설정

```xml
<bean id="digestFilter" class= "org.springframework.security.web.authentication.www.DigestAuthenticationFilter">
  <property name="userDetailsService" ref="jdbcDaoImpl"/>
  <property name="authenticationEntryPoint" ref="digestEntryPoint"/>
  <property name="userCache" ref="userCache"/>
</bean>

<bean id="digestEntryPoint" class= "org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint">
  <property name="realmName" value="Contacts Realm via Digest Authentication"/>
  <property name="key" value="acegi"/>
  <property name="nonceValiditySeconds" value="10"/>
</bean>
```

<br/><br/><br/><br/>

## 17. Remember-Me 인증(Authentication)

### 17.1. 개요

<br/>

### 17.2. 단순 Hash기반 토큰(Token) 접근

```
base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          As identifiable to the UserDetailsService
password:          That matches the one in the retrieved UserDetails
expirationTime:    The date and time when the remember-me token expires, expressed in milliseconds
key:               A private key to prevent modification of the remember-me token
```

```xml
<http>
  ...
  <remember-me key="myAppKey"/>
</http>
```

<br/>

### 17.3. 지속적인 토큰(Token) 접근

```xml
<http>
  ...
  <remember-me data-source-ref="someDataSource"/>
</http>
```

```SQL
create table persistent_logins (username varchar(64) not null,
								series varchar(64) primary key,
								token varchar(64) not null,
								last_used timestamp not null)
```

<br/>

### 17.4. Remember-Me 인터페이스와 구현

```java
Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication);
```

<br/>

### 17.4.1. TokenBasedRememberMeServices

```xml
<bean id="rememberMeFilter" class= "org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter">
  <property name="rememberMeServices" ref="rememberMeServices"/>
  <property name="authenticationManager" ref="theAuthenticationManager" />
</bean>

<bean id="rememberMeServices" class= "org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices">
  <property name="userDetailsService" ref="myUserDetailsService"/>
  <property name="key" value="springRocks"/>
</bean>

<bean id="rememberMeAuthenticationProvider" class= "org.springframework.security.authentication.RememberMeAuthenticationProvider">
  <property name="key" value="springRocks"/>
</bean>
```

<br/>

### 17.4.2. PersistentTokenBasedRememberMeServices

<br/><br/><br/><br/>

## 18. 사이트간 요청 위조(Cross Site Request Forgery, CSRF)
이번 절에서는 Spring Security의 사이트간 요청 위조(CSRF) 관련 설정을 설명한다.

### 18.1. CSRF 공격
Spring Security가 어떻게 CSRF 공격으로부터 어플리케이션을 보호할 수 있는지 논하기 전에 CSRF 공격이 무엇인지부터 설명할 것이다. 이해를 위해 예제를 살펴보자.

한 은행 웹사이트에서 로그인한 사용자가 다른 은행 계좌로 돈을 이체할 수 있도록 폼을 제공한다고 가정하자. 예를 들어, HTTP 요청(request)는 아래와 같다고 하자.

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
```

사용자는 은행 웹사이트에 인증되어 있는 상태에서 로그아웃하지 않고 악성 웹사이트를 방문한다. 악성 웹사이트는 아래와 같은 형식의 HTML페이지를 가지고 있다.

```html
<form action="https://bank.example.com/transfer" method="post">
  <input type="hidden"
  	name="amount"
  	value="100.00"/>
  <input type="hidden"
  	name="routingNumber"
  	value="evilsRoutingNumber"/>
  <input type="hidden"
  	name="account"
  	value="evilsAccountNumber"/>
  <input type="submit"
  	value="Win Money!"/>
</form>
```

'Win Money!'라는 글귀에 이끌려 사용자는 submit 버튼을 클릭한다. 이렇게 되면 악의적 사용자에게 100달러를 의도치 않게 이체하게 된다. 악성 웹사이트는 당신의 쿠키를 볼 수 없지만, 은행 관련된 쿠키는 여전히 요청과 함께 전송되기 때문에 이러한 상황이 발생할 수 있다.

최악의 경우 Javascript를 사용하여 이 모든 과정을 자동화 할 수도 있다. 즉, submit 버튼을 클릭하지 않고 악성 사이트를 방문하는 것만으로도 이 같은 상황이 발생할 수 있다는 것이다. 그럼 어떻게 이런 공격을 방어할 수 있을까?

<br/><br/>

### 18.2. Synchronizer 토큰 패턴(Synchronizer Token Pattern)
문제는 은행 웹사이트의 HTTP 요청과 악성 웹사이트 요청이 완전 동일하다는 것이다. 즉, 악성 웹사이트에서 오는 요청은 거부하고 은행 웹사이트에서 오는 요청은 허용할 수 있는 방법이 없는 것이다. CSRF 공격을 막기 위해서는 요청에 악성 사이트가 제공할 수 없는 것을 포함시키고 이를 확인해야 한다.

한 가지 해결책으로는 [동기화 토큰 패턴(Synchronizer Token Pattern)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)을 사용하는 것이 있다. 이 방법에서는 각 요청에 세션 쿠키 뿐만 아니라 HTTP 매개변수로써 무작위로 생성된 토큰을 필요로 하도록 한다. 요청이 전송되면 서버는 매개변수의 예상값을 찾아서 요청의 실제값과 비교한다. 만약 값이 일치하지 않으면 요청은 실패한다.

어떤 상태를 업데이트하는 HTTP 요청들에 대해서만 토큰을 필수로 포함하도록 할 수도 있다. 이것은 동일 출처 정책(same origin policy)이 악성 사이트가 응답(response)을 읽을 수 없도록 하기 때문에 안정하게 수행된다. 또한 토큰이 유출되지 않도록 HTTP GET에 토큰을 포함시키지 않는다.

그럼 이제 상기에서 논의 했던 예제 상황이 어떻게 변경이 될 수 있는지 확인하자. 임의로 생성된 토큰이 _csrf라는 HTTP 매개변수로 전달된다고 가정하자. 이체 요청은 아래와 같을 것이다.

```
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=<secure-random>
```

_csrf 매개변수에 랜덤값을 추가했다는 것을 알 수 있다. 이제 악성 웹사이트는 _csrf 매개변수의 올바른 값을 추측할 수 없어 서버가 실제 토큰값과 예상 토큰값을 비교할 경우 전송은 실패할 것이다.

<br/><br/>

### 18.3. CSRF 방어를 사용하는 경우
그렇다면 CSRF 방어는 언제 사용해야 할까? 일단 일반 사용자에 의해 브라우저가 작동되는 어떠한 요청에 의해서든 CSRF 방어를 적용하는 것을 권장한다. 다만, 브라우저가 아닌 클라이언트를 사용하는 서비스를 만드는 경우에는 CSRF 방어를 비활성화해야 할 경우도 있다.

### 18.3.1. CSRF 방어와 JSON
일반적으로 하는 질문은 "javascript에 의한 JSON 요청에도 CSRF 방어를 적용해야 하는가?"이다. 대답은 "그렇다"이다. 그러나 JSON 요청에 영향을 줄 수 있는 CSRF 악용이 있을 수 있으므로 매우 조심해야 한다. 예를 들어, 악성 사용자는 [아래와 같이 JSON를 사용하여 CSRF를 생성](http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html)할 수 있다.

```jsp
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
  <input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

이것은 아래와 같은 JSON 형식을 서버로 보내게 된다.

```json
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
```

어플리케이션이 Content-Type의 유효성을 검사하지 않으면 이 공격에 노출되게 된다. Content-Type 유효성을 검사하는 Spring MVC 어플리케이션은 설정에 따라 아래와 같이 URL 접미어를 ".json"으로 끝나게 만들어 노출시킬 수 있다.


```jsp
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
  <input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
  <input type="submit" value="Win Money!"/>
</form>
```

<br/>

### 18.3.2. CSRF와 Stateless<sup id="footkey12">[#12](#footnote12)</sup> 브라우저 어플리케이션
만약 어플리케이션이 Stateless 하면 어떨까? 이것은 반드시 보호받는다는 의미가 아니다. 사실상 사용자가 주어진 요청에 대해 웹 브라우저에서 어떤 행동을 취할 필요가 없다면 CSRF 공격에 여전히 취약할 수 있다.

예를 들어, 어플리케이션이 JSESSIONID 대신 인증용으로 모든 상태를 포함하는 커스터마이징된 쿠키를 사용한다고 가정해보자. CSRF 공격이 발생하면 커스터마이징된 쿠키는 이전 예제에서 JSESSIONID가 전송된 것과 같은 방식으로 요청과 함께 전송될 것이다.

브라우저는 이전 예제에서 JSESSIONID 쿠키가 전송된 것과 같은 방식으로 어떤 요청이든 사용자명과 비밀번호를 자동으로 포함하기 때문에 기본 인증을 사용하는 사용자는 CSRF 공격에 취약하다.

__<sub id="footnote12">#12</sub>__ <sub>stateless하다는 것은 서버에 어떠한 클라이언트 상태도 저장하지 않는다는 의미이다. 그렇기 때문에 클라이언트는 데이터 요청 시 마다 자신을 인증할 수 있는 정보를 포함하여 전송하여야 한다. -옮긴이 (참고: http://anster.tistory.com/163) ([읽던 곳으로 돌아가기](#footkey12))</sub>

<br/><br/><br/>

### 18.4. Spring Security CSRF 방어 사용하기
그렇다면 CSRF 공격으로부터 사이트를 보호하기 위해 Spring Security를 사용하려면 어떻게 해야 할까? Spring Security의 CSRF 방어를 사용하는 단계는 아래와 같다.
- 적절한 HTTP 메서드 사용
- CSRF 방어 설정
- CSRF 토큰 포함하기

<br/>

### 18.4.1. 적절한 HTTP 메서드 사용
CSRF 공격을 방어하기 위한 첫 번째 단계는 웹 사이트에서 적절한 HTTP 메서드를 사용하도록 하는 것이다. 특히, Spring Security CSRF 방어를 사용하려면 먼저 어플리케이션 상태를 수정하는 HTTP 메서드(PATCH, POST, PUT, DELETE)를 사용하고 있는지 확인하여야 한다.

이 부분은 Spring Security에서만 요구하는 것이 아니라 CSRF 공격 예방을 위해 일반적으로 요구하는 부분이다. 그 이유는 HTTP GET에 개인정보를 포함하면 정보가 유출될 수 있기 때문이다. 중요한 정보는 GET 대신 POST 메서드를 사용하는 것에 대한 가이드는 [RFC 2616 Section 15.1.3 Encoding Sensitive Information in URI's](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)를 참고하면 좋다.

<br/>

### 18.4.2. CSRF 방어 설정
다음 단계는 어플리케이션 내에 Spring Security의 CSRF 방어 기능을 적용하는 것이다. 일부 프레임워크들은 사용자의 세션을 무효화하는 방식으로 유효하지 않은 CSRF 토큰을 처리하지만, 이것은 자체적인 문제를 야기할 수 있다. 그와 다르게 기본적으로 Spring Security의 CSRF 방어는 HTTP 403 접근 거부가 되도록 만든다. 이는 ```InvalidCsrfTokenException```을 다르게 처리하도록 ```AcessDeniedhandler```를 설정하여 커스터마이징 할 수도 있다.

Spring Security 4.0부터 CSRF 방어는 XML 설정으로 설정이 가능하다. 만약 CSRF 방어를 사용하지 않고 싶다면, 아래와 같이 XML 설정을 사용하면 된다.

```xml
<http>
	<!-- ... -->
	<csrf disabled="true"/>
</http>
```

CSRF 방어는 또한 Java 설정으로도 설정이 가능하다. 만약 CSRF 방어를 사용하지 않고 싶다면, 아래와 같이 Java설정을 사용하면 된다. CSRF 방어 설정 방법에서의 추가적인 커스터마이징은 csrf() Javadoc을 참고하길 바란다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
  	http
  	.csrf().disable();
  }
}
```

<br/>

### 18.4.3. CSRF 토큰 포함하기

### Form 전송
마지막 단계는 모든 PATCH, POST, PUT 및 DELETE 메소드에 CSRF 토큰을 포함시키는 것이다. 포함시키는 방법 중 하나는 요청속성 ```_csrf```을 사용하는 것이다. 아래 예제는 이에 대한 jsp 예제이다.

```jsp
<c:url var="logoutUrl" value="/logout"/>
<form action="${logoutUrl}" method="post">
  <input type="submit" value="Log out" />
  <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>
</form>
```

보다 쉬운 방법은 Spring Security JSP 태그 라이브러리의 [csrfInput 태그](#305-csrf입력-태그-csrfinput)를 사용하는 것이다.

> Spring MVC ```<form:form>``` 태그 또는 [Thymeleaf 2.1+](http://www.thymeleaf.org/whatsnew21.html#reqdata)를 사용하고 ```@EnableWebSecurity```를 사용하는 경우 ```CsrfToken```은 자동으로 포함된다. (```CsrfRequestDataValueProcessor``` 사용)

<br/>

### Ajax와 JSON 요청(Request)
JSON을 사용하는 경우 HTTP 매개변수 내에 CSRF 토큰을 포함하여 전송할 수 없다. 그 대신 HTTP 헤더 내에 토큰을 포함하여 전송할 수 있다. 전형적인 패턴은 메타 태그 내에 CSRF 토큰을 포함하는 것이다. 아래는 관련 JSP 예제이다.

```jsp
<html>
  <head>
  	<meta name="_csrf" content="${_csrf.token}"/>
  	<!-- default header name is X-CSRF-TOKEN -->
  	<meta name="_csrf_header" content="${_csrf.headerName}"/>
  	<!-- ... -->
  </head>
  <!-- ... -->
```
메타태그를 수동으로 생성하는 대신 Spring Security JSP 태그 라이브러리에서 제공하는 보다 간단한 [csrfMetaTags 태그](#306-csrf메타-태그-csrfmetatags)를 사용할 수 있다.

그러고 나서 모든 Ajax 요청 내에 토큰을 포함시킬 수 있다. jQuery를 사용한다면 아래와 같이 작성 할 수 있다.

```javascript
$(function () {
  var token = $("meta[name='_csrf']").attr("content");
  var header = $("meta[name='_csrf_header']").attr("content");
  $(document).ajaxSend(function(e, xhr, options) {
  	xhr.setRequestHeader(header, token);
  });
});
```

jQuery의 대안으로는 [cujoJS](http://cujojs.com)의 rest.js를 추천한다. [rest.js](https://github.com/cujojs/rest) 모듈은 RESTful 방식으로 HTTP 요청 및 응답을 위한 고급 기능들을 제공한다. 핵심 기능은 클라이언트에 인터셉터를 연결하여 필요에 따라 상황에 맞게 HTTP 클라이언트 추가동작을 설정하는 것이다.

```javascript
var client = rest.chain(csrf, {
  token: $("meta[name='_csrf']").attr("content"),
  name: $("meta[name='_csrf_header']").attr("content")
});
```

설정된 클라이언트는 CSRF 방어가 되는 자원들을 요청해야하는 어플리케이션의 어떤 요소에든 공유될 수 있다. rest.js의 jQuery와 비교되는 중요한 차이점 중 하나는 설정된 클라이언트로 만들어진 요청들만이 CSRF 토큰을 포함하고 있다는 것이며, jQuery는 모든 요청에 토큰이 포함된다는 것이다. 토큰을 어떠한 요청에 포함시킬지 그 범위를 지정하는 기능은 CSRF 토큰이 제 3자에게 노출되는 것을 방지할 수 있다. rest.js에 대한 자세한 내용은 [rest.js 레퍼런스 문서](https://github.com/cujojs/rest/tree/master/docs)를 보는 것이 좋다.

<br/>

### CookieCsrfTokenRepository
사용자가 ```CsrfToken```을 쿠키에 유지하려는 경우가 있을 수 있다. 기본적으로 ```CookieCsrfTokenRepository```는 ```XSRF-TOKEN```라는 쿠키를 만들고 ```X-XSRF-TOKEN```라는 헤더정보 또는 ```_csrf``` HTTP 매개변수로부터 이 쿠키값을 읽어올 수 있다. 이러한 기본사항들은 [AngularJS](https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection)에서 나온 개념을 사용한 것이다.

아래는 XML을 사용하여 CookieCsrfTokenRepository를 설정하는 예제이다.

```xml
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	      class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	      p:cookieHttpOnly="false"/>
```

> 이 샘플에서는 명시적으로 ```cookieHttpOnly=false```를 설정한다. 이는 JavaScript(즉, AngularJS)가 쿠키를 읽을 수 있게 하려면 꼭 필요한 부분이다. JavaScript(즉, AngularJS)로 직접 쿠키를 읽을 필요가 없다면 보안을 향상시키기 위해 ```cookieHttpOnly=false```를 생략하는 것을 추천한다.

아래는 Java 설정을 사용하여 CookieCsrfTokenRepository를 설정하는 예제이다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.csrf()
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
	}
}
```

> 이 샘플에서는 명시적으로 ```cookieHttpOnly=false```를 설정한다. 이는 JavaScript(즉, AngularJS)가 쿠키를 읽을 수 있게 하려면 꼭 필요한 부분이다. JavaScript(즉, AngularJS)로 직접 쿠키를 읽을 필요가 없다면 보안을 향상시키기 위해 (```CookieCsrfTokenRepository.withHttpOnlyFalse()``` 대신 ```new CookieCsrfTokenRepository()```를 사용하여) ```cookieHttpOnly=false```를 생략하는 것을 추천한다.

<br/><br/><br/>

### 18.5. CSRF 주의사항
CSRF를 구현할 때 몇 가지 주의사항이 있다.

### 18.5.1. Timeout
첫 번째 이슈는 CSRF 토큰이 HttpSession에 저장되므로 HttpSession이 만료되는 즉시 설정된 ```AccessDeniedHandler```가 ```InvalidCsrfTokenException```을 수신할 것이라는 것이다. 기본적인 ```AccessDeniedHandler```를 사용하는 경우 브라우저는 HTTP 403을 전달 받을 것이고 오류메시지가 표시될 것이다.

> CsrfToken가 기본적으로 쿠키에 저장되지 않는 이유를 물을 때가 있다. 쿠키에 저장하지 않는 이유는 다른 도메인에서 헤더를 설정할 수 있는 취약점이 있기 때문이다(즉, 쿠키를, 토큰을 수정할 수 있는 것이다). 이는 [```X-Requested-With``` 헤더가 있으면 Ruby on Rails가 더 이상 CSRF 확인을 생략하지 않는 이유](http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/)와 같다. 취약점에 대한 상세한 내용은 [webappsec.org](http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html)를 참고하면 된다. 또 다른 이유로는 상태(즉, timeout)를 제거하면 토큰이 손상될 경우 토큰을 강제로 만료시킬 수 없다는 단점이 있다.

timeout이 발생한 사용자들에게 보다 나은 사용자 경험을 제공하는 간단한 방법은 세션이 만료될 예정임을 알리는 JavaScript를 사용하는 것이다. 사용자는 버튼을 클릭하여 세션을 계속 진행하고 리프레쉬할 수 있다.

다른 방법으로는 ```AccessDeniedHandler```를 커스터마이징하여 ```InvalidCsrfTokenException```를 원하는 방식으로 처리하는 것이 있다. ```AccessDeniedHandler```를 커스터마이징하는 방법으로는 [xml](#4113-access-denied-handler) 또는 [Java 설정](https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/groovy/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.groovy#L64)이 있다.

마지막으로 만료되지 않는 [CookieCsrfTokenRepository](#cookiecsrftokenrepository)를 사용하도록 어플리케이션에 설정하는 방법이 있다. 앞서 언급했던 바와 같이 이는 세션을 사용하는 것만큼 안전하지 않지만 이러한 설정만으로도 충분한 경우가 많다.

<br/>

### 18.5.2. 로그인하기
로그인 요청을 위조하는 것을 방지하기 위해 CSRF 공격에 대해서도 로그인 폼을 보호해야 한다. ```CsrfToken```은 HttpSession에 저장되기 때문에 ```CsrfToken``` 토큰 속성에 접근하는 즉시 HttpSession가 생성된다고 생각하면 된다. RESTful/stateless 아키텍처에서는 이런 부분이 별로 좋지 않은 것으로 간주되지만, 현실은 실질적인 보안을 구현하는데 어플리케이션 상태 정보가 필요하다. 상태정보가 없으면 코큰이 손상되어도 아무것도 할 수 없다. 사실 말하자면, CSRF 토큰은 크기가 상당히 작아서 아키텍처에 거의 영향을 미치지 않아야 한다.

로그인 폼을 보호하는 일반적인 방법은 폼 전송 전에 유효한 CSRF 토큰을 얻기 위해 JavaScript 함수를 사용하는 것이다. 이렇게 하면 앞서 설명한 세션 timeout에 대해 생각할 필요가 없다. 폼 전송 이전에 세션이 만들어지기 때문이다([CookieCsrfTokenRepository](#cookiecsrftokenrepository)가 설정되어 있지 않은 경우). 사용자는 로그인 페이지에 머무를 수 있고 원하는 때에 사용자명과 비밀번호를 입력하여 전송할 수 있다. 이렇게 하기 위해서는 Spring Security가 제공하는 ```CsrfTokenArgumentResolver```를 활용하고 [37.5.2. CsrfToken 확인하기](#3752-csrftoken-확인하기)에 기술된 것과 같은 엔드 포인트를 노출 할 수 있다.

<br/>

### 18.5.3. 로그아웃하기
CSRF를 추가하면 LogoutFilter가 HTTP POST만 사용하게끔 업데이트 된다. 이렇게 하면 로그아웃 시 CSRF 토큰이 필요하고 악성 사용자가 강제로 다른 사용자를 로그아웃시킬 수 없게 된다.

접근방식 중 하나는 로그아웃을 위한 폼을 사용하는 것이다. 링크가 실제로 필요한 경우에는 JavaScript를 사용해서 POST로 동작하는 링크를 만들 수 있다(즉, 숨겨진 폼이라고 생각하면 될 것 같다). JavaScript가 비활성화된 브라우저의 경우 선택적으로 링크를 통해 POST로 동작하는 로그아웃 확인 페이지로 사용자를 이동시킬 수 있다.

정말로 HTTP GET을 로그아웃과 함께 사용하고 싶다면 그렇게 할 수는 있지만 일반적으로 권장하지 않는다. 예를 들어, 아래 예제는 URL /lougout이 어떤 HTTP 메소드로 요청되든 로그아웃을 수행하는 Java 설정이다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.logout()
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"));
	}
}
```

<br/>

### 18.5.4. Multipart(파일 업로드)
CSRF 방어를 multipart/form-data와 함게 사용하는 데에는 두 가지 옵션이 있다. 각 옵션에는 절충점이 있다.
- [Spring Security 앞에 MultipartFilter 배치하기](#spring-security-앞에-multipartfilter-배치하기)
- [Action에 CSRF 토큰 포함하기](#action에-csrf-토큰-포함하기)

> Spring Security의 CSRF 방어와 다중 파일 업로드를 함께 사용하기 전에 먼저 CSRF 방어 없이 업로드 할 수 있는지 확인해야 한다. Spring에서 multipart 폼을 사용하는 것에 대한 보다 많은 정보는 Spring 레퍼런스의 [17.10 Spring's multipart (file upload) support](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-multipart)와 [MultipartFilter javadoc](https://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html)에서 확인할 수 있다.

### Spring Security 앞에 MultipartFilter 배치하기
첫 번째 옵션은 Spring Security 필터 앞에 ```MultipartFilter```가 지정되었는지 확인하는 것이다. Spring Security 필터 앞에 ```MultipartFilter```를 지정하면 ```MultipartFilter```를 호출할 수 있는 권한이 없어진다. 이는 누군가 서버에 임시파일을 둘 수 없음을 의미한다. 오직 권한이 부여된 사용자만 파일을 전송하여 어플리페이션이 처리하게 할 수 있다. 일반적으로 이것은 임시 파일 업로드가 서버에 무시할 수 없는 영향을 주기 때문에 권장되는 방법이다.

Java 설정을 사용하여 Spring Security 필터 앞에 ```MultipartFilter```가 지정되도록 하기 위해서는 아래와 같이 ```beforeSpringSecurityFilterChain```을 오버라이드하면 된다.

```java
public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}
```

XML 설정을 사용하여 Spring Security 필터 앞에 ```MultipartFilter```가 지정되도록 하기 위해서는 아래와 같이 web.xml에서 springSecurityFilterChain 이전에 ```MultipartFilter```의 <filter-mapping>을 위치시켜야 한다.

```xml
<filter>
	<filter-name>MultipartFilter</filter-name>
	<filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>
</filter>
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
	<filter-name>MultipartFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
	<filter-name>springSecurityFilterChain</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
```

### Action에 CSRF 토큰 포함하기
두 번째 옵션은 Spring Security 필터 뒤에 ```MultipartFilter```를 위치시키고 폼의 action 속성에 CSRF를 쿼리 매개변수로 포함하는 것이다. 아래는 jsp에서의 사용 예제이다.

```jsp
<form action="./upload?${_csrf.parameterName}=${_csrf.token}" method="post" enctype="multipart/form-data">
```

이 접근방식의 단점은 쿼리 매개변수가 유출될 수 있다는 것이다. 유출되지 않도록 본문 또는 헤더 내에 중요한 데이터를 배치하는 것이 가장 좋은 방법이다. 추가적인 정보는 [RFC 2616 15.1.3 Encoding Sensitive Information in URI's](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)를 찾아보면 된다.

<br/>

### 18.5.5. HiddenHttpMethodFilter
```HiddenHttpMethodFilter```는 Spring Security의 필터 앞에 위치해야 한다. 일반적으로 이렇게 위치시키지만 CSRF 공격을 방어할 때는 특히 추가적인 영향이 있을 수 있으므로 더욱 이렇게 설정해주어야 한다.

```HiddenHttpMethodFilter```는 POST에서 HTTP 메서드를 재정의하므로 실질적인 문제는 거의 발생하지 않는다. 그러나 Spring Security의 필터 앞에 배치하는 것이 가장 좋다.

<br/><br/><br/>

### 18.6. 기본값 재정의(Override)하기
Spring Security의 목표는 보안을 위협하는 공격으로부터 사용자들을 보호하기 위한 기본값들을 제공하는 것이다. 그렇다고 해서 모든 기본값들을 그냥 그대로 써야 한다는 것은 아니다.

예를 들어, CsrfTokenRepository를 커스터마이징하여 ```CsrfToken```을 저장하는 방식을 재정의할 수 있다.

또한 RequestMatcher를 커스터마이징하여 어떤 요청이 CSRF 공격으로부터 보호될 것인지 정할 수 있다. 간단히 말해서 Spring Security의 CSRF 방어가 원하는대로 정확하게 작동하지 않으면 동작을 커스터마이징할 수 있다. xml 설정을 사용할 때 이러한 커스터마이징에 대한 자세한 내용을 알고 싶다면 [41.1.18. ```<csrf>```](#41118-csrf)을 참고하고, Java 설정을 사용할 때는 ```CsrfConfigurer``` javadoc을 참고하면 된다.

<br/><br/><br/><br/><br/>

## 19. CORS

<br/><br/><br/><br/><br/>

## 20. Security HTTP 응답헤더
이제 다양한 security 헤더를 응답(response)에 추가하는 Spring Security 기능에 대해서 설명할 것이다.

### 20.1. 기본 Security 헤더
Spring Security는 사용자가 쉽게 어플리케이션 보안을 위한 기본 security 헤더를 삽입할 수 있게 한다. Spring Security의 기본설정은 아래 헤더를 포함하는 것이다.

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

> Strict-Transport-Security는 HTTPS 요청에만 추가된다.

각 헤더에 대한 자세한 내용은 아래 위치을 참고하면 된다.
- [20.1.1. Cache 제어](#2011-cache-제어)
- [20.1.2. Content Type 옵션](#2012-content-type-옵션)
- [20.1.3. HTTP Strict Transport Security (HSTS)](#2013-http-strict-transport-security-hsts)
- [20.1.5. X-Frame-Options](#2015-x-frame-options)
- [20.1.6. X-XSS-Protection](#2016-x-xss-protection)

모든 클라이언트가 각 헤더정보를 모두 사용하는 것은 아니므로 추가 테스트를 해야 한다.

특정 헤더를 커스터마이징 할 수 있다. 예를 들어, HTTP 응답헤더가 아래와 같기를 원한다고 가정하자.

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
```

특히, 모든 기본 헤더가 아래와 같이 커스터마이징되기를 원한다고 하자.
- X-Frame-Options은 같은 도메인으로부터 전달되어 온 어떤 요청이든 허용한다.
- HTTP Strict Transport Security (HSTS)는 응답(response)에 추가되지 않는다.

이와 같은 요건들을 Java 설정을 통해 쉽게 설정할 수 있다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers()
				.frameOptions().sameOrigin()
				.httpStrictTransportSecurity().disable();
	}
}
```

Spring Security XML 설정을 사용하는 경우 아래와 같이 설정할 수 있다.

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
		<hsts disable="true"/>
	</headers>
</http>
```

기본값이 아닌 명시적 설정을 사용하고자 하는 경우 기본값을 비활성화 할 수 있다.

Spring Security의 Java 설정을 사용하는 경우 [Cache 제어](#2011-cache-제어)만 헤더에 추가하고자 하면 아래 예제와 같이 하면 된다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
  	http
  	// ...
  	.headers()
  		// do not use any default headers unless explicitly listed
  		.defaultsDisabled()
  		.cacheControl();
  }
}
```

다음은 [Cache 제어](#2011-cache-제어)만 추가하는 XML 설정이다.

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
```

필요하다면 아래 Java 설정을 사용해서 모든 HTTP Security 응답헤더를 비활성화할 수도 있다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
  	http
  	// ...
  	.headers().disable();
  }
}
```

필요하다면 아래 XML 설정으로도 모든 HTTP Security 응답헤더를 비활성화 할 수 있다.

```xml
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
```

### 20.1.1. Cache 제어
### 20.1.2. Content Type 옵션
### 20.1.3. HTTP Strict Transport Security (HSTS)
### 20.1.4. HTTP Public Key Pinning (HPKP)

### 20.1.5. X-Frame-Options
웹페이지가 하나의 프레임(Frame)으로 제공되는 것은 보안상 문제의 소지가 있을 수 있다. 예를 들어, CSS 스타일링을 사용하여 사용자들을 속이고 그들이 의도하지 않은 것을 클릭하게 만들 수 있다.([비디오 데모](https://www.youtube.com/watch?v=3mk0RySeNsU)) 예를 들어, 은행에 로그인한 사용자가 다른 사용자에게 접근 권한을 부여하는 버튼을 클릭하게 되는 경우가 바로 이에 해당한다. 이런 종류의 공격을 [Clickjacking](https://en.wikipedia.org/wiki/Clickjacking)이라고 한다.

> Clickjacking을 다루는 또 다른 최신방법은 [20.1.7. Content Security Policy(CSP)](#2017-content-security-policycsp)에 기술되어 있다.

Clickjacking 공격을 줄이는 방법은 여러가지가 있다. 예를 들어, 레거시 브라우저를 Clickjacking으로부터 보호하려하는 경우 [frame breaking 코드](https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script)를 사용할 수 있다. 완벽하지는 않지만 frame breaking 코드는 레거시 브라우저에 적용할 수 있는 가장 최선의 방식이다.

Clickjacking을 다루는 최신 방법은 [X-Frame-Options](https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options) 헤더를 사용하는 것이다.

```
X-Frame-Options: DENY
```

X-Frame-Options 응답헤더는 브라우저에게 위와 같은 응답헤더를 가진 사이트는 프레임에 렌더링되지 않게 보호하도록 지시한다. 기본적으로 Spring Security는 iframe 내 렌더링을 비활성화한다.

frame-options 요소를 사용하여 X-Frame-Options을 커스터마이징 할 수 있다. 아래는 동일한 도메인 내에 iframe을 허용하는 "X-Frame-Options: SAMEORIGIN"을 사용한 예제이다.

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options
		policy="SAMEORIGIN" />
	</headers>
</http>
```

마찬가지로 아래 Java 설정에서 동일한 출처를 사용하도록 프레임 옵션을 커스터마이징할 수도 있다.

```java
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
  	http
  	// ...
  	.headers()
  		.frameOptions()
  			.sameOrigin();
  }
}
```

### 20.1.6. X-XSS-Protection
### 20.1.7. Content Security Policy(CSP)
### Content Security Policy 설정하기
### 추가적인 Resources
### 20.1.8. Referrer Policy
### Refferer Policy 설정하기
### 20.2. 사용자정의 헤더
### 20.2.1. Static Headers
### 20.2.2. HeaderWriter
### 20.2.3. DelegatingRequestMatcherHeaderWriter

## 21. 세션 관리 (Session Management)
HTTP 세션 관련 기능은 Filter가 위임하는 ```SessionManagementFilter``` 및 ```SessionAuthenticationStrategy``` 인터페이스의 조합으로 처리된다. 일반적인 사용방법에는 세션 고정 공격 방지, 세션 timeout 방지, 인증된 사용자가 동시에 열 수 있는 세션 수 제한 등이 포함된다.

### 21.1. SessionManagementFilter
```SessionManagementFilter```는 현재 요청(request)에서 사용자가 인증되었는지 알기 위해 사전 인증 또는 Remember-Me 인증과 같은 비상호적인 인증 메커니즘을 통해 ```SecurityContextHoler```의 현재 내용과 대조하여 ```SecurityContextRepository```의 내용을 확인한다<sup id="footkey11">[#11](#footnote11)</sup>. SecurityContextRepository에 security context가 포함되면 SessionManagementFilter는 아무 일도 하지 않는다. SecurityContextRepository에 security context가 포함되지 않고 thread-local ```SecurityContext```가 (익명이 아닌) ```Authentication``` 객체를 포함하고 있으면 SessionManagementFilter는 바로 앞선 필터에서 인증한 사용자로 간주한다. 그리고 나서 설정된 ```SessionAuthenticationStrategy```를 호출한다.

사용자가 현재 인증되지 않은 경우 필터는 (예를 들어, timeout으로 인한) 유효하지 않은 세션 ID가 요청되었는지 확인하고 설정된 ```InvalidSessionStrategy```가 있다면 이를 호출한다. 가장 일반적인 동작은 고정 URL로 리다이렉션하는 것이다. 이는 표준 구현체 ```SimpleRedirectInvalidSessionStrategy```안에 캡슐화되어 있다. 또한 [앞서 설명한 것과 같이](#633-세션-관리하기) 네임스페이스를 통해 유효하지 않은 세션 URL을 설정할 수도 있다.

### 20.2. SessionAuthenticationStrategy
### 20.3. 동시성 제어(Concurrency Control)
### 20.3.1. 현재 인증된 사용자 및 해당 세션에 대한 SessionRegistry 질의하기(Querying)

__<sub id="footnote11">#11</sub>__ <sub>인증 요청중에는 필터가 호출되지 않기 때문에 폼 로그인과 같은 인증 후 리다이렉션을 수행하는 메커니즘은 ```SessionManagementFilter```에 의해 감지되지 않는다. 이러한 경우 세션 관리 기능을 별도로 처리하여야 한다. ([읽던 곳으로 돌아가기](#footkey11))</sub>

## 22. 익명 인증(Anonymous Authentication)
### 22.1. 개요
### 22.2. 설정
### 22.3. AuthenticationTrustResolver

## 23. WebSocket Security
### 23.1. WebSocket 설정
### 23.2. WebSocket 인증(Authentication)
### 23.3. WebSocket 승인(Authorization)
### 23.3.1. WebSocket 승인 알림
### 메시지 타입으로 WebSocket 승인
### 목적지로 WebSocket 승인
### 23.3.2. 아웃바운드 메시지(Outbound Messages)
### 23.4. 동일출처정책(SOP, Same Origin Policy) 적용하기
### 23.4.1. 왜 같은 출처인가?
### 23.4.2. 출처를 허용하는 Spring WebSocket
### 23.4.3. STOMP(Simple Text Oriented Massaging Protocol) 헤더에 CSRF 추가하기
### 23.4.4. WebSocket에서 CSRF 비활성화하기
### 23.5. SockJS와 함께 동작하기
### 23.5.1. SockJS와 ```<frame-options>```
### 23.5.2. SockJS와 CSRF 방어 수준 조정하기

# [5] 승인(Authorization)

## 24. 승인 아키텍처(Authorization Architecture)
### 24.1. 권한(Authorities)
### 24.2. 사전 호출 처리
### 24.2.1. AccessDecisionManager
### 24.2.2. 투표행위 기반 AccessDecisionManager 구현
### RoleVoter
### AuthenticatedVoter
### 사용자정의 Voter
### 24.3. 호출 처리 이후
### 24.4. 계층적인 구조를 가진 권한

## 25. 보안객체(Secure Object) 구현
### 25.1. AOP Alliance (MethodInvocation) Security Interceptor
### 25.1.1. Explicit MethodSecurityInterceptor 설정
### 25.2. AspectJ (JoinPoint) Security Interceptor

## 26. 표현식 기반 접근 제어
### 26.1. 개요
### 26.1.1. 일반적인 내장 표현식
### 26.2. 웹 Security 표현식
### 26.2.1. 웹 Security 표현식 내에서 Bean 참조하기
### 26.2.2. 웹 Security 표현식 내에서 URL 경로 변수 (Path Variables) 참조하기
### 26.3. 메서드 Security 표현식
### 26.3.1. @Pre, @Post 어노테이션
### @PreAuthorize와 @PostAuthorize를 사용한 접근제어
### @PreFilter와 @PostFilter를 사용한 필터링
### 26.3.2. 내장 표현식
### PermissionEvaluator 인터페이스
### 메서드 Security 메타 어노테이션(Meta Annotation)

# [6] 추가항목

## 27. 도메인 객체 Security(Domain Object Security) (ACLs)
### 27.1. 개요
### 27.2. 키 개념
### 27.3. 시작하기

## 28. 사전인증(Pre-Authentication) 시나리오
### 28.1. 사전인증(Pre-Authentication) 프레임워크 클래스
### 28.1.1. AbstractPreAuthenticatedProcessingFilter
### J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource
### 28.1.2. PreAuthenticatedAuthenticationProvider
### 28.1.3. Http403ForbiddenEntryPoint
### 28.2. 구체적인 구현체
### 28.2.1. 요청헤더 인증(Request-Header Authentication) (Siteminder)
### Siteminder 설정 예제
### 28.2.2. Java EE Container 인증(Authentication)

## 29. LDAP 인증 (LDAP Authentication)
### 29.1. 개요
### 29.2. Spring Security와 함께 LDAP 사용하기
### 29.3. LDAP 서버 설정하기
### 29.3.1. 내장 테스트 서버 사용하기
### 29.3.2. 바인드 인증(Bind Authentication) 사용하기
### 29.3.3. 권한 불러오기(Loading Authorities)
### 29.4. 구현 클래스들
### 29.4.1. LdapAuthenticator 구현체
### 공통 기능
### BindAuthenticator
### PasswordComparisonAuthenticator
### 29.4.2. LDAP 서버에 연결하기
### 29.4.3. LDAP 검색 객체
### FilterBasedLdapUserSearch
### 29.4.4. LdapAuthoritiesPopulator
### 29.4.5. Spring Bean 설정
### 29.4.6. LDAP 속성과 사용자정의 UserDeatils
### 29.5. 유효한 디렉토리 인증(Active Directory Authentication)
### 29.5.1. ActiveDirectoryLdapAuthenticationProvider
### 유효한 디렉토리 에러 코드

## 30. JSP 태그 라이브러리
### 30.1. Taglib 선언하기
### 30.2. 권한부여 태그 ```authorize```
### 30.2.1. 테스팅을 위한 태그 인증 비활성화하기
### 30.3. 인증 태그 ```authentication```
### 30.4. 접근제어 태그 ```accesscontrollist```
### 30.5. CSRF입력 태그 ```csrfInput```
### 30.6. CSRF메타 태그 ```csrfMetaTags```

## 31. Java Authentication and Authorization Service (JAAS) Provider
### 31.1. 개요
### 31.2. AbstractJaasAuthenticationProvider
### 31.2.1. JAAS CallbackHandler
### 31.2.2. JAAS AuthorityGranter
### 31.3. DefaultJaasAuthenticationProvider
### 31.3.1. InMemoryConfiguration
### 31.3.2. DefaultJaasAuthenticationProvider 설정 예제
### 31.4. JaasAuthenticationProvider
### 31.5. Subject 객체로 실행하기

## 32. CAS 인증(CAS Authentication)
### 32.1. 개요
### 32.2. CAS인증은 어떻게 동작하는가?
### 32.2.1. Spring Security와 CAS 상호작용 과정
### 32.3. CAS 클라이언트 설정
### 32.3.1. Service Ticket 인증(Authentication)
### 32.3.2. Single Logout
### 32.3.3. CAS로 Stateless 서비스 인증하기
### Ticket이 부여된 Proxy를 얻기 위해 CAS 설정하기
### Proxy Ticket 사용하여 Stateless 서비스 부르기
### 32.3.4. Proxy Ticket 인증(Authentication)

## 33. X.509 인증(Authentication)
### 33.1. 개요
### 33.2. 웹서비스에 X.509 인증 추가하기
### 33.3. Tomcat에 SSL 설치하기

## 34. 보안객체(Secure Object) 콜백단계에서 인증(Authentication) 교체하기
### 34.1. 개요
### 34.2. 설정

## 35. Spring Security 암호화 모듈
### 35.1. 소개
### 35.2. 암호화기(Encryptors)
### 35.2.1. BytesEncryptor
### 35.2.2. TextEncryptor
### 35.3. 키 생성기(Key Generator)
### 35.3.1. BytesKeyGenerator
### 35.3.2. StringKeyGenerator
### 35.4. 비밀번호 인코딩하기

## 36. 동시성 지원
### 36.1. DelegatingSecurityContextRunnable
### 36.2. DelegatingSecurttyContextExecutor
### 36.3. Spring Security 동시성 클래스들

## 37. Spring MVC와의 통합
### 37.1. @EnableWebMvcSecurity
### 37.2. MvcRequestMatcher
### 37.3. @AuthenticationPrincipal
### 37.4. Spring MVC Async와의 통합
### 37.5. Spring MVC와 CSRF와의 통합
### 37.5.1. CSRF 토큰 자동 포함
### 37.5.2. CsrfToken 확인하기
Spring Security는 Spring MVC 매개변수<sup id="footkey13">[#13](#footnote13)</sup>에 대한 현재 ```CsrfToken```을 자동으로 확인할 수 있는 ```CsrfTokenArgumentResolver```를 제공한다. @EnableWebSecurity를 사용하면 Spring MVC 설정에 이 ```CsrfTokenArgumentResolver```가 자동으로 추가된다. XML 기반 설정을 사용하는 경우에는 직접 추가해야 한다.

일단 ```CsrfTokenArgumentResolver```가 잘 설정되면 정적 HTML기반 어플리케이션에 ```CsrfToken```을 노출할 수 있다.

```java
@RestController
public class CsrfController {
	@RequestMapping("/csrf")
	public CsrfToken csrf(CsrfToken token) {
		return token;
	}
}
```

다른 도메인에는 ```CsrfToken```을 비밀로 유지하는 것이 중요하다. 즉, [CORS(Cross Origin Sharing)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)을 사용하는 경우 ```CsrfToken```을 어떤 외부도메인에든 노출하지 말아야 한다.

__<sub id="footnote13">#13</sub>__ <sub>Spring MVC 매개변수(argument)가 의미하는 것은 Spring 컨트롤러에 들어오는 파라미터를 의미한다. 클라이언트와의 데이터를 주고 받을 때 발생한다. -옮긴이([읽던 곳으로 이동하기](#footkey13))</sub>

# [7] Spring Data와의 통합

## 38. Spring Data와 Spring Security 설정

## 39. @Query에서의 Security 표현식

# [8] 부록

## 40. Security Database Schema
### 40.1. User Schema
### 40.1.1. Group 인증
### 40.2. 로그인 지속 스키마 (Persistent Login/Remember-Me Schema)
### 40.3. ACL 스키마
### 40.3.1. HyperSQL
### 40.3.2. PostgreSQL
### 40.3.3. MySQL와 MariaDB
### 40.3.4. Microsoft SQL Server
### 40.3.5. Oracle

## 41. Security 네임스페이스
### 41.1. 웹 어플리케이션 Security
### 41.1.1. ```<debug>```
### 41.1.2. ```<http>```
#### ```<http>``` 속성
- <b>access-decision-manager-ref</b>
- <b>authentication-manager-ref</b>
- <b>auto-config</b>
- <b>create-session</b>
- <b>disable-url-rewriting</b>
- <b>entry-point-ref</b>
- <b id="jaas-api-provision">jaas-api-provision</b>
- <b>name</b>
- <b>once-per-request</b>
- <b>pattern</b>
- <b>realm</b>
- <b>request-matcher</b>
- <b>request-matcher-ref</b>
- <b>security</b>
- <b>security-context-repository-ref</b>
- <b>servlet-api-provision</b>
- <b>use-expressions</b>
#### ```<http>``` 하위요소
### 41.1.3. ```<access-denied-handler>```
#### ```<access-denied_handler>``` 상위 요소
#### ```<access-denied_handler>``` 속성
### 41.1.4. ```<cors>```
#### ```<cors>``` 속성
#### ```<cors>``` 상위 요소
### 41.1.5. ```<headers>```
#### ```<headers>``` 속성
#### ```<headers>``` 상위 요소
#### ```<headers>``` 하위 요소
### 41.1.6. ```<cache-control>```
#### ```<cache-controle>``` 속성
#### ```<cache-controle>``` 상위 요소
### 41.1.7. ```<hsts>```
#### ```<hsts>``` 속성
#### ```<hsts>``` 상위 요소
### 41.1.8. ```<hpkp>```
#### ```<hpkp>``` 속성
#### ```<hpkp>``` 상위 요소
### 41.1.9. ```<pins>```
#### ```<pins>``` 하위 요소
### 41.1.10. ```<pin>```
#### ```<pin>``` 속성
#### ```<pin>``` 상위 요소
### 41.1.11. ```<content-security-policy>```
#### ```<content-security-policy>``` 속성
#### ```<content-security-policy>``` 상위 요소
### 41.1.12. ```<referrer-policy>```
#### ```<referrer-policy>``` 속성
#### ```<referrer-policy>``` 상위 요소
### 41.1.13. ```<frame-options>```
#### ```<frame-options>``` 속성
#### ```<frame-options>``` 상위 요소
### 41.1.14. ```<xss-protection>```
#### ```<xss-protection>``` 속성
#### ```<xss-protection>``` 상위 요소
### 41.1.15. ```<content-type-option>```
#### ```<content-type-option>``` 속성
#### ```<content-type-option>``` 상위 요소
### 41.1.16. ```<header>```
#### ```<header>``` 속성
#### ```<header>``` 상위 요소
### 41.1.17. ```<anonymous>```
#### ```<anonymous>``` 상위 요소
#### ```<anonymous>``` 속성
### 41.1.18. ```<csrf>```
#### ```<csrf>``` 상위 요소
#### ```<csrf>``` 속성
### 41.1.19. ```<custom-filter>```
#### ```<custom-filter>``` 상위 요소
#### ```<custom-filter>``` 속성
### 41.1.20. ```<expression-handler>```
#### ```<expression-handler>``` 상위 요소
#### ```<expression-handler>``` 속성
### 41.1.21. ```<form-login>```
#### ```<form-login>``` 상위 요소
#### ```<form-login>``` 속성
### 41.1.22. ```<http-basic>```
#### ```<http-basic>``` 상위 요소
#### ```<http-basic>``` 속성
### 41.1.23. ```<http-firewall>```
#### ```<http-firewall>``` 속성
### 41.1.24. ```<intercept-url>```
#### ```<intercept-url>``` 상위 요소
#### ```<intercept-url>``` 속성
### 41.1.25. ```<jee>```
#### ```<jee>``` 상위 요소
#### ```<jee>``` 속성
### 41.1.26. ```<logout>```
#### ```<logout>``` 상위 요소
#### ```<logout>``` 속성
### 41.1.27. ```<openid-login>```
#### ```<openid-login>``` 상위 요소
#### ```<openid-login>``` 속성
#### ```<openid-login>``` 하위 요소
### 41.1.28. ```<attribute-exchange>```
#### ```<attribute-exchange>``` 상위 요소
#### ```<attribute-exchange>``` 속성
#### ```<attribute-exchange>``` 하위 요소
### 41.1.29. ```<openid-attribute>```
#### ```<openid-attribute>``` 상위 요소
#### ```<openid-attribute>``` 속성
### 41.1.30. ```<port-mappings>```
#### ```<port-mappings>``` 상위 요소
#### ```<port-mappings>``` 속성
### 41.1.31. ```<port-mapping>```
#### ```<port-mapping>``` 상위 요소
#### ```<port-mapping>``` 속성
### 41.1.32. ```<remember-me>```
#### ```<remember-me>``` 상위 요소
#### ```<remember-me>``` 속성
### 41.1.33. ```<request-cache>```
#### ```<request-cache>``` 상위 요소
#### ```<request-cache>``` 속성
### 41.1.34. ```<session-management>```
#### ```<session-management>``` 상위 요소
#### ```<session-management>``` 속성
#### ```<session-management>``` 하위 요소
### 41.1.35. ```<concurrency-control>```
#### ```<concurrency-control>``` 상위 요소
#### ```<concurrency-control>``` 속성
#### error-if-maximum-exceeded
#### expired-url
#### expired-url
#### max-sessions
#### session-registry-alias
#### session-registry-ref
### 41.1.36. ```<x509>```
#### ```<x509>``` 상위 요소
#### ```<x509>``` 속성
### 41.1.37. ```<filter-chain-map>```
#### ```<filter-chain-map>``` 속성
#### ```<filter-chain-map>``` 하위 요소
### 41.1.38. ```<filter-chain>```
#### ```<filter-chain>``` 상위 요소
#### ```<filter-chain>``` 속성
### 41.1.39. ```<filter-security-metadata-source>```
#### ```<filter-security-metadata-source>``` 속성
#### ```<filter-security-metadata-source>``` 하위 요소
### 41.2. WebSocket Security
### 41.2.1. ```<websocket-message-broker>```
#### ```<websocket-message-broker>``` 속성
#### ```<websocket-message-broker>``` 하위 요소
### 41.2.2. ```<intercept-message>```
#### ```<intercept-message>``` 상위 요소
#### ```<intercept-message>``` 속성
### 41.3. 인증(Authentication) Services
### 41.3.1. ```<authentication-manager>```
#### ```<authentication-manager>``` 속성
#### ```<authentication-manager>``` 하위 요소
### 41.3.2. ```<authentication-provider>```
#### ```<authentication-provider>``` 상위 요소
#### ```<authentication-provider>``` 속성
#### ```<authentication-provider>``` 하위 요소
### 41.3.3. ```<jdbc-user-service>```
#### ```<jdbc-user-service>``` 속성
### 41.3.4. ```<password-encoder>```
#### ```<password-encoder>``` 상위 요소
#### ```<password-encoder>``` 속성
#### ```<password-encoder>``` 하위 요소
### 41.3.5. ```<salt-source>```
#### ```<salt-source>``` 상위 요소
#### ```<salt-source>``` 속성
### 41.3.6. ```<user-service>```
#### ```<user-service>``` 속성
#### ```<user-service>``` 하위 요소
### 41.3.7. ```<user>```
#### ```<user>``` 상위 요소
#### ```<user>``` 속성
### 41.4. 메서드 Security
### 41.4.1. ```<global-method-security>```
#### ```<global-method-security>``` 속성
#### ```<global-method-security>``` 하위 요소
### 41.4.2. ```<after-invocation-provider>```
#### ```<after-invocation-provider>``` 상위 요소
#### ```<after-invocation-provider>``` 속성
### 41.4.3. ```<pre-post-annotation-handling>```
#### ```<pre-post-annotation-handling>``` 상위 요소
#### ```<pre-post-annotation-handling>``` 하위 요소
### 41.4.4. ```<invocation-attribute-factory>```
#### ```<invocation-attribute-factory>``` 상위 요소
#### ```<invocation-attribute-factory>``` 속성
### 41.4.5. ```<post-invocation-advice>```
#### ```<post-invocation-advice>``` 상위 요소
#### ```<post-invocation-advice>``` 속성
### 41.4.6. ```<pre-invocation-advice>```
#### ```<pre-invocation-advice>``` 상위 요소
#### ```<pre-invocation-advice>``` 속성
### 41.4.7. ```<protect-pointcut>```
#### ```<protect-pointcut>``` 상위 요소
#### ```<protect-pointcut>``` 속성
### 41.4.8. ```<intercept-methods>```
#### ```<intercept-methods>``` 속성
#### ```<intercept-methods>``` 하위 요소
### 41.4.9. ```<method-security-metadata-source>```
#### ```<method-security-metadata-source>``` 속성
#### ```<method-security-metadata-source>``` 하위 요소
### 41.4.10. ```<protect>```
#### ```<protect>``` 상위 요소
#### ```<protect>``` 속성
### 41.5. LDAP 네임스페이스 옵션
### 41.5.1. ```<ldap-server>```
#### ```<ldap-server>``` 속성
### 41.5.2. ```<ldap-authentication-provider>```
#### ```<ldap-authentication-provider>``` 상위 요소
#### ```<ldap-authentication-provider>``` 속성
#### ```<ldap-authentication-provider>``` 하위 요소
### 41.5.3. ```<password-compare>```
#### ```<password-compare>``` 상위 요소
#### ```<password-compare>``` 속성
#### ```<password-compare>``` 하위 요소
### 41.5.4. ```<ldap-user-service>```
#### ```<ldap-user-service>``` 속성

## 42. Spring Security 의존성 (Dependencies)
### 42.1. spring-security-core
### 42.2. spring-security-remoting
### 42.3. spring-security-web
### 42.4. spring-security-ldap
### 42.5. spring-security-config
### 42.6. spring-security-acl
### 42.7. spring-security-cas
### 42.8. spring-security-openid
### 42.9. spring-security-taglibs

## 43. 프록시(Proxy) 서버 설정

## 44. Spring Security FAQ (자주 찾는 질문)
### 44.1. 일반적인 질문
### 44.1.1. Spring Security가 모든 어플리케이션 보안 요구 사항을 처리하는가?
### 44.1.2. 왜 web.xml security를 사용하지 않는가?
### 44.1.3. Spring Security 적용을 위해 필요한 Java 및 Spring Framework 버전은 무엇인가?
### 44.1.4. Spring Security를 처음 접한 입장에서 HTTPS를 통해 CAS Single Sign-On을 지원하는 어플리케이션을 구축해야 한다. 이 어플리케이션은 특정 URL에 대해 로컬 인증을 허용하고 여러 최종 사용자 정보 출처(LDAP및 JDBC)에 대해 인증한다. 설정 파일을 찾아 복사했지만 제대로 작동하지 않는다. 무엇이 잘못된 것인가?
### 44.2. 일반적인 문제
### 44.2.1. 로그인을 시도하면 "잘못된 자격증명(Bad Credentials)"이라는 오류 메시지가 표시된다. 무엇이 문제인가?
### 44.2.2. 로그인을 시도하면 어플리케이션이 무한 루프에 빠진다. 무슨 현상인가?
### 44.2.3. "엑세스가 거부되었습니다(사용자는 익명)"라는 메시지와 함께 예외가 발생한다. 무엇이 문제인가?
### 44.2.4. 어플리케이션에서 로그아웃한 후에도 보안 페이지가 계속 표시되는 이유가 무엇인가?
### 44.2.5. "SecurityContext에서 인증 객체를 찾을 수 없습니다"라는 메시지와 함께 예외가 발생한다. 무엇이 문제인가?
### 44.2.6. LDAP 인증이 작동하지 않는다. 설정에 무슨 문제가 있나?
### 44.2.7. 세션 관리
### 44.2.8. 사용자가 한번에 두 번 이상 로그인할 수 없게 하기 위해서 Spring Security의 동시 세션 제어를 사용하는 중이다. 하지만 로그인을 한 후에 다른 브라우저 창을 열어 로그인을 시도 하는 것은 막을 수가 없다. 이런 경우 왜 두 번 이상의 로그인이 가능한 것인가?
### 44.2.9. Spring Security를 통해 인증할 때 왜 세션 아이디가 변경되는가?
### 44.2.10. Tomcat (또는 다른 서블릿 컨테이너)를 사용하는 중이며 로그인 페이지에서 HTTPS를 사용하도록 설정하였다.(로그인 이후에는 HTTP로 전환된다.) 그러나 제대로 작동하지 않는다. 인증 후 로그인 페이지로 돌아간다.
### 44.2.11. HTTP와 HTTPS 간 전환을 하지 않음에도 불구하고 세션이 여전히 손실된다.
### 44.2.12. 동시 세션 제어를 사용하고 로그아웃을 했으며 허용된 세션을 초과하지 않았음에도 불구하고 로그인이 되지 않는다.
### 44.2.13. 세션을 생성하지 않도록 create-session 속성을 naver로 설정했음에도 불구하고 어느순간 세션을 생성한다.
### 44.2.14. POST 실행할 때 403 Forbidden이 발생한다.
### 44.2.15. RequestDispatcher를 사용하여 다른 URL로 요청을 전달하였는데 보안 제한조건이 적용되지 않는다.
### 44.2.16. Spring Security ```<global-method-security>```요소를 어플리케이션 Context에 추가했지만 Spring MVC Controller bean(Struts action 등)에 security 어노테이션을 추가하면 그 어노테이션은 영향을 미치지 않는 것 같다.
### 44.2.17. 확실하게 인증된 사용자이지만 일부 요청중에 SecurityContextHolder에 접근하려고 하면 인증이 null값이다. 사용자 정보를 볼 수 없는 이유는 무엇인가?
### 44.2.18. ```authorize``` JSP 태그는 URL 속성을 사용할 때 메서드 Security 어노테이션을 무시한다.
### 44.3. 아키텍처(Architecture) 관련 질문
### 44.3.1. 각각의 클래스들이 어떤 패키지에 있는지 어떻게 알 수 있는가?
### 44.3.2. 네임스페이스 요소는 기존 Bean 설정에 어떻게 매핑되는가?
### 44.3.3. "ROLE_"은 무엇을 의미하며 권한 이름이 왜 필요한가?
### 44.3.4. Spring Security로 작업하기 위해서 어떤 종속성들을 추가해야 하는지 어떻게 알 수 있는가?
### 44.3.5. 임베디드 ApacheDS LDAP 서버를 실행하려면 어떤 의존성이 필요한가?
### 44.3.6. UserDetailsService란 무엇이며 필요한 것인가?
### 44.4. 일반적인 방법에 관한 요청
### 44.4.1. 사용자 이름(username)보다 자세한 정보를 통해 로그인하도록 하고 싶다. 예를 들어, '회사이름'과 같은 새로운 로그인 필드를 추가하려면 어떻게 해야 하는가?
### 44.4.2. 요청 URL의 프래그먼트(#) 값만 다른 경우 (예: /foo#bar, /foo#blah) 다른 intercept-url 제약조건을 적용하려면 어떻게 해야 하는가?
### 44.4.3. UserDetailsService 내에 사용자 IP 주소(또는 다른 웹 요청 데이터) 정보에 접근하려면 어떻게 해야 하는가?
### 44.4.4. UserDetailsService에서 HttpSession를 접근하려면 어떻게 해야 하는가?
### 44.4.5. UserDetailsService 내에서 사용자 비밀번호에 접근하려면 어떻게 해야 하는가?
### 44.4.6. 어플리케이션 내에서 보안 URL을 동적으로 정의하려면 어떻게 해야 하는가?
### 44.4.7. LDAP에 대해 인증하면서 데이터베이스로부터 사용자 권한을 불러오려면 어떻게 해야 하는가?
### 44.4.8. 네임스페이스에 의해 생성된 bean의 속성을 변경하고자 한다. 하지만 이것을 지원하는 스키마가 없다. 네임스페이스 사용을 포기하지 않고 할 수 있는 방법은 무엇인가?

## 45. 3.x에서 4.x로 마이그레이션(Migration)
